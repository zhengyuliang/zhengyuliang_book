{"./":{"url":"./","title":"说明","keywords":"","body":"技术文章简介 总结所有技术文章，以后方像汇总，装订成书，并发表于网络 前端技术知识 技术知识主要来源于网络与我这段时间的学习所得，合适的时候本人也会按自己的思路去编写一定的技术文档 生活经验总结 经验总结而尔，就写写自己的一些心点，没有大用 使用说明 gitbook serve // 搭建服务内容 简单技术教程 http://www.chengweiyang.cn/gitbook/index.html Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2020-02-26 15:34:48 "},"technology/":{"url":"technology/","title":"技术类","keywords":"","body":"这里是技术说明 每天记录一篇技术文，复习一遍其中一篇技术文章 WebSocket vue 高级技巧 Vue.set()和this.$set()应用的场景 JavaScript之防抖（Debounce）和节流（Throttle） JavaScript数组求并集，交集和差集 探讨JavaScript的优雅写法 ES6之Set和Map数据结构深入学习 axios知识点 理解Vue.mixin，利用Vue.mixin正确的偷懒 7道javascript题，让你理解基本的javascript 异步神器Async-await介绍与填坑 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-27 10:08:42 "},"technology/axios知识点.html":{"url":"technology/axios知识点.html","title":"axios知识点","keywords":"","body":"axios知识点及vue的使用axios方式 简介 Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中 ，它提供了一个更强大、更灵活的功能集。 特性 在浏览器中创建 XMLHttpRequests 在 node.js 则创建 http 请求 支持 Promise API 支持拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 支持Chrome、火狐、Edge、IE8+等浏览器 安装 使用 npm安装: $ npm install axios 使用 bower: $ bower install axios 或者直接使用 cdn: 使用举例 执行 GET 请求 注：推荐使用啥方法详情 // 为给定 ID 的 user 创建请求 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // GET 参数可以放到params里（推荐） get使用params参数内容 axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 还可以使用ECMAScript 2017里的async/await，添加 `async` keyword to your outer function/method. //使用async/await使用详情 async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); } } async/await 是 ECMAScript 2017新提供的功能 ，Internet Explorer 和一些旧的浏览器并不支持 执行 POST 请求 //post使用的是对象，这里也要注意 axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 axios.all //注意axios.all的使用流程等 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { // 两个请求现在都执行完成 })); axios API 可以通过向 axios 传递相关配置来创建请求 。请求图片要考虑下为什么，是什么原因？ axios(config) // 发送 POST 请求 axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' } }); // GET 请求远程图片 response参数 axios({ method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream' }) .then(function(response) { response.data.pipe(fs.createWriteStream('ada_lovelace.jpg')) }); axios(url[, config]) // 发送 GET 请求（默认的方法） axios('/user/12345'); 请求方法的别名 为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 并发 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例 可以使用自定义配置新建一个 axios 实例 axios.create([config]) const instance = axios.create({ baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: {'X-Custom-Header': 'foobar'} }); 实例方法 以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置项 下面是创建请求时可用的配置选项，注意只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 { // `url` 是用于请求的服务器 URL url: \"/user\", // `method` 是创建请求时使用的方法 method: \"get\", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: \"https://some-domain.com/api/\", // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 \"PUT\", \"POST\" 和 \"PATCH\" 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {\"X-Requested-With\": \"XMLHttpRequest\"}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: \"brackets\"}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: \"Fred\" }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: \"janedoe\", password: \"s00pers3cret\" }, // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\" responseType: \"json\", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: \"XSRF-TOKEN\", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // \"proxy\" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: \"127.0.0.1\", port: 9000, auth: : { username: \"mikeymike\", password: \"rapunz3l\" } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 响应结构 axios请求的响应包含以下信息： { // `data` 由服务器提供的响应 data: {}, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: \"OK\", // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用 then 时，会接收下面这样的响应： axios.get(\"/user/12345\") .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置的默认值/defaults 你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值 axios.defaults.baseURL = \"https://api.example.com\"; axios.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; axios.defaults.headers.post[\"Content-Type\"] = \"application/x-www-form-urlencoded\"; 自定义实例默认值 // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: \"https://api.example.com\" }); // 在实例已创建后修改默认值 instance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; 配置的优先级 配置会以一个优先顺序进行合并。 请求的config > 实例的 defaults 属性 > 库默认值： // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： var myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 var instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); 错误处理 axios.get(\"/user/12345\") .catch(function (error) { if (error.response) { // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else { // Something happened in setting up the request that triggered an Error console.log(\"Error\", error.message); } console.log(error.config); }); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围 axios.get(\"/user/12345\", { validateStatus: function (status) { return status 取消请求 使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： const CancelToken = axios.CancelToken; const source = CancelToken.source(); axios.get('/user/12345', { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // handle error } }); axios.post('/user/12345', { name: 'new name' }, { cancelToken: source.token }) // cancel the request (the message parameter is optional) source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： var CancelToken = axios.CancelToken; var cancel; axios.get(\"/user/12345\", { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // 取消请求 cancel(); 可以使用同一个 cancel token 取消多个请求 请求时使用 application/x-www-form-urlencoded axios会默认序列化 JavaScript 对象为 JSON. 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置. 浏览器 在浏览器环境，你可以使用 URLSearchParams API : const params = new URLSearchParams(); params.append('param1', 'value1'); params.append('param2', 'value2'); axios.post('/foo', params); URLSearchParams不是所有的浏览器均支持 除此之外，你可以使用qs库来编码数据: const qs = require('qs'); axios.post('/foo', qs.stringify({ 'bar': 123 })); // Or in another way (ES6), import qs from 'qs'; const data = { 'bar': 123 }; const options = { method: 'POST', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify(data), url, }; axios(options); 当然，同浏览器一样，你还可以使用 qs library. Promises axios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. TypeScript支持 axios 包含 TypeScript definitions. import axios from \"axios\"; axios.get(\"/user?ID=12345\"); vue中使用axios的多种方式 安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入 为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton 使用npm npm install axios 使用cdn: 解决post方法使用application/x-www-form-urlencoded格式编码数据 设置 headers:{ 'Content-type': 'application/x-www-form-urlencoded'} axios.post('url',data,{headers:{ 'Content-type': 'application/x-www-form-urlencoded'}}) // 不想在每次请求都设置的话，可以集中设置下 axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'; 仅仅这样并没有达到想要的效果，post的body主体中还是{\"age\":10}这样的格 式，并不是我们想要的query参数。引入Qs，这个库是axios里面包含的，不需要再下载了 import qs from 'qs' var data = qs.stringify({\"name\":\"xie\"}); axios.post('url',data).then() axios默认是不让ajax请求头部携带cookie的 axios 解决跨域cookie丢失问题 设置 axios.defaults.withCredentials = true 即可 示例代码： axios.defaults.withCredentials = true; var param = new URLSearchParams(); param.append(\"vCode\",vcode); axios.post('http://localhost',param) .then(function(res) { var rs=res.data; console.log(rs.data); }) .catch(function(err) { console.log(err); }); 配合vue axios并没有install 方法，所以是不能使用vue.use()方法的。 那么难道每个文件都要来引用一次？解决方法有很多种： 结合 vue-axios使用 axios 改写为 Vue 的原型属性 结合 Vuex的action 方法1：结合 vue-axios使用 vue-axios 用于将axios集成到Vuejs的小包装器 github: https://github.com/axios/axios 安装： npm install --save axios vue-axios vue-axios是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了 首先在主入口文件main.js中引用 import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios,axios); 之后就可以使用了，在组件文件中的methods里去使用了 getNewsList(){ this.axios.get('api/getNewsList').then((response)=>{ this.newsList=response.data.data; }).catch((response)=>{ console.log(response); }) }, 方法2： axios 改写为 Vue 的原型属性 首先在主入口文件main.js中引用，之后挂在vue的原型链上 import axios from 'axios' Vue.prototype.$axios= axios 在组件中使用 this.$axios.get('api/getNewsList').then((response)=>{ this.newsList=response.data.data; }).catch((response)=>{ console.log(response); }) 方法3：结合vuex import axios from 'axios' import { Message } from 'element-ui' import store from '@/store' import { getToken } from '@/utils/auth' // 创建axios实例 const service = axios.create({ baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间 }) // request拦截器 service.interceptors.request.use(config => { // Do something before request is sent if (store.getters.token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } return config }, error => { // Do something with request error console.log(error) // for debug Promise.reject(error) }) // respone拦截器 service.interceptors.response.use( response => response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) { // Message({ // message: res.message, // type: 'error', // duration: 5 * 1000 // }); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', { // confirmButtonText: '重新登录', // cancelButtonText: '取消', // type: 'warning' // }).then(() => { // store.dispatch('FedLogOut').then(() => { // location.reload();// 为了重新实例化vue-router对象 避免bug // }); // }) // } // return Promise.reject('error'); // } else { // return response.data; // } error => { console.log('err' + error)// for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }) return Promise.reject(error) }) export default service import request from '@/utils/request' //使用 export function getInfo(params) { return request({ url: '/user/info', method: 'get', params }); } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-14 15:47:03 "},"technology/WebSocket.html":{"url":"technology/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket WebSocket 是一种网络通信协议，很多高级功能都需要它。 一、为什么需要 WebSocket？ 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 二、简介 WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 三、客户端的简单示例 WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 var ws = new WebSocket(\"wss://echo.websocket.org\"); ws.onopen = function(evt) { console.log(\"Connection open ...\"); ws.send(\"Hello WebSockets!\"); }; ws.onmessage = function(evt) { console.log( \"Received Message: \" + evt.data); ws.close(); }; ws.onclose = function(evt) { console.log(\"Connection closed.\"); }; 四、客户端的 API WebSocket 客户端的 API 如下。 4.1 WebSocket 构造函数 WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 var ws = new WebSocket('ws://localhost:8080'); 4.2 webSocket.readyState readyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 switch (ws.readyState) { case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break; } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-13 18:40:40 "},"technology/智能照明项目说明.html":{"url":"technology/智能照明项目说明.html","title":"智能照明项目说明","keywords":"","body":"ut-smart-light 智能照明项目前端工程 环境和依赖 node v10.16.x yarn v1.19.1 webpack eslint @vue/cli ~3 ant-design-vue - Ant Design Of Vue 实现 vue-cropper - 头像裁剪组件 @antv/g2 - Alipay AntV 数据可视化图表 Viser-vue - antv/g2 封装实现 ant-design-vue-pro - 定制文档 权限管理 - admin pro权限管理思路 移除权限校验参考 - 移除模板中的权限管理 请注意，我们强烈建议本项目使用 Yarn 包管理工具，这样可以与本项目演示站所加载完全相同的依赖版本 (yarn.lock) 。由于我们没有对依赖进行强制的版本控制，采用非 yarn 包管理进行引入时，可能由于 Pro 所依赖的库已经升级版本而引入了新版本所导致的问题。作者可能会由于时间问题无法及时排查而导致您采用本项目作为基项目而出现问题。 项目下载和运行 拉取项目代码 git clone http://192.168.104.43/utfe/ut-smart-light.git cd ut-smart-light 安装依赖 yarn install 开发模式运行 yarn run serve 编译项目 yarn run build Lints and fixes files yarn run lint 其他说明 项目使用的 vue-cli3, 请更新您的 cli 关闭 Eslint (不推荐) 移除 package.json 中 eslintConfig 整个节点代码, vue.config.js 下的 lintOnSave 值改为 false 开启组件按需加载 /src/main.js L7 修改为 import './core/lazy_use' 修改 Ant Design 配色，在文件 vue.config.js 中，其他 less 变量覆盖参考 ant design 官方说明 css: { loaderOptions: { less: { modifyVars: { /* less 变量覆盖，用于自定义 ant design 主题 */ 'primary-color': '#F5222D', 'link-color': '#F5222D', 'border-radius-base': '4px', }, javascriptEnabled: true, } } } 约定式提交和git-flow 本项目commit message遵守约定式提交 代码管理遵守git-flow工作流模式 约定式提交 npm vs yarn 命令对比: https://yarnpkg.com/zh-Hans/docs/migrating-from-npm#toc-cli-commands-comparison 项目相关资料 需求文档：http://192.168.104.43/lightProduct/product 蓝狐设计稿：https://lanhuapp.com/url/7e6lW-qm3Ne （如果没有权限找陈迪强邀请） 表单校验 项目中所有设计的表单组件必须有约束和校验（特殊要求除外）. 模块结构相关约定 举例：设备模块 device # 功能模块 ├── common # 公共层（需要时才建立） ├── components # 公共组件（需要时才建立） ├── services # 接口服务层（service依赖api+transformer，做参数的处理和结果的转换） ├── transformers # 转换层（前端组件数据结构和服务端结果不一致再这里转换） └── views # 子功能模块 ├── device-controller # 设备控制子模块 (下面的子目录还可以继续重复上层的结构) │ ├── common │ ├── components │ ├── services │ └── transformers ├── device-manage # 设备管理子模块 └── region-manage # 区域分组子模块 这样做的好处是把基于模块化的思想，就近原则管理自己的依赖 如果子模块之间有依赖，就需要把依赖抽象提取到父模块中，变成一个公共依赖，防止循环依赖。 目录和文件命名约定 目录名称：kebab-case 全部小写，连字符-链接多个单词 文件名称：PascalCase 全部大写驼峰（通用的默认约定除外，例如：index.vue, index.js...之类.） Ajax模块注意事项 const url = '/api/web/user/delete/batch' const data = { id: 123 } // 因为Ajax和axios内部对data没有进行序列化处理，所以axios会根据data的类型进行切换 // 'Content-Type'，如果时string就使用 application/x-www-form-urlencoded // 不是string类型，就使用application/json，但是服务端接口不一定能够调用成功， // 所以**非string**类型最好使用`qs`处理下 // 调用src/api/utils中的stringify Ajax.post(url, data) // Ajax.post(url, stringify(data)) WebSocket 项目中的WebSocket已经对接完毕，数据转换已经完成 业务页面使用 import { PubSubBus } from '@commonset/pubsubbus' export default { mounted () { // data的数据结构看import('@commonset/types').CommonEvent PubSubBus.$on('eventName', (eventName, data) => { // 干你想干的事 }) this.$once('hook:beforeDestroy', function () { PubSubBus.$off('eventName') }) } } 事件类型和数据结构 src/common/websocket/constants/EventConstants.js ```javascript // 转换器的代码 export const smartHomeMessageTransformer = { /** transform - 转换 @param { import('@/types').SmartHomeEvent } data @returns { import('@commonset/types').CommonEvent } - 通过用的消息结构 */ transform: function (data) { return { type: data.type, code: 0, message: ${data.eventType}.${data.bussType}, data: { content: '', extraProps: data.body } } } } > 事件类型 ```javascript export const SmartLightEventTypes = { 'device.status.update': '设备状态更新', 'host.status.update': '主机状态更新', 'user.update': '用户信息更新，后跟角色类型', 'user.update.superAdminlight': '超级管理员', 'user.update.administrator': '管理员', 'user.update.operator': '操作员', 'user.update.reporter': '告警人', 'user.delete': '用户被删除，后跟角色类型', 'user.delete.superAdminlight': '超级管理员', 'user.delete.administrator': '管理员', 'user.delete.operator': '操作员', 'user.delete.reporter': '告警人', 'region.update': '区域信息更新', 'region.delete': '区域被删除', 'message.add': '有新消息，后跟消息类型', 'message.add.warning': '告警消息', 'scene.update': '策略方案更新，后跟linkageType、periodType', 'scene.delete': '策略方案被删除，后跟linkageType periodType', 'scene.delete.manual': '手动策略方案', 'scene.delete.auto.daily': '日方案', 'scene.delete.auto.weekly': '周方案', 'scene.delete.auto.holiday': '节假日方案', 'scene.update.manual': '手动策略方案', 'scene.update.auto.daily': '日方案', 'scene.update.auto.weekly': '周方案', 'scene.update.auto.holiday': '节假日方案' } 数据结构 // 其中的body字段，全部转换到extraProps字段上 // 转换之后的数据结构，业务界面接收到的数据结构 { type: data.type, code: 0, message: `${data.eventType}.${data.bussType}`, data: { content: '', extraProps: data.body } } { \"设备状态更新\": { \"type\": \"device.status.update\", \"bussType\": 7000, \"eventType\": 4, \"body\": { \"deviceId\": 1, \"productDevId\": 0, \"productDevStatus\": 0 } }, \"主机状态更新\": { \"type\": \"host.status.update\", \"bussType\": 7001, \"eventType\": 4, \"body\": { \"hostId\": 1, \"hostStatus\": 1 } }, \"eventType\": { \"1\": \"新增\", \"2\": \"删除\", \"3\": \"修改\" }, \"新增\": { \"type\": \"*.add\", \"bussType\": 0, \"eventType\": 1, \"body\": { \"entityId\": 1 } }, \"修改\": { \"type\": \"*.update\", \"bussType\": 0, \"eventType\": 3, \"body\": { \"entityId\": 1 } }, \"删除\": { \"type\": \"*.delete\", \"bussType\": 0, \"eventType\": 2, \"body\": { \"entityId\": 1, \"messageContent\": \"提示信息\" } } } vue-ext目录 vue-ext目录，放置对vue的扩展， main文件中调用setup方法 mixins 目前扩展了vue，添加了两个方法 // api mixins两个函数，方便对api结果处理。 import { apiResolveHandler, apiRejectHandler } from '@/api/utils' export default { methods: { apiResolver: apiResolveHandler, apiRejecter: apiRejectHandler } } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-14 09:41:07 "},"technology/理解Vue.mixin，利用Vue.mixin正确的偷懒.html":{"url":"technology/理解Vue.mixin，利用Vue.mixin正确的偷懒.html","title":"理解Vue.mixin，利用Vue.mixin正确的偷懒","keywords":"","body":"理解Vue.mixin，利用Vue.mixin正确的偷懒 刚进入vue项目，有部分细节功能不清楚。段期做了一个vue项目，看到使用vue.mixin功能，就想去了解透怎么应用及使用原理，故有了下文 关于Vue.mixin ，官方解释如下 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。 （不理解，所以看只有看例子咯） Vue.mixin为我们提供了两种混入方式：局部混入和全局混入； （好像有关vue都基本上都有局部与合局加载一说，~） 局部混入 顾名思义就是部分混入，也就是只有引入了mixin的混入对象才可以使用，并且只有在引入了mixin混入对象的组件中才生效； 首先自己搭建Vue的开发环境，然后我们在src目录中新建两个vue文件，分别是page1.vue和page2.vue； //page1.vue page1的值是: export default { data () { return { } }, } //page2.vue page2的值是: export default { data () { return { } } } //app.vue page1 page2 export default { name: 'App', methods:{ method1(){ this.$router.push('/page1'); }, method2(){ this.$router.push('/page2'); } } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 在src目录下创建router.js文件，配置路由实现跳转 // router.js import Vue from \"vue\"; import VueRouter from \"vue-router\"; Vue.use(VueRouter); import page1 from \"./page1\"; import page2 from \"./page2\"; const routes=[ {path:\"/page1\",component:page1}, {path:\"/page2\",component:page2} ] const router=new VueRouter({ routes }) export default router 最后将路由引入main.js中： // main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router.js' Vue.config.productionTip = false /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '' }) 完成上述准备工作之后，我们可以看到现在的页面效果如下： 没有报错，我们开始正式进入学习Vue.mixin： 注：终于开始学习了，难得呀 首先我们在src目录下新建一个名为mixin的文件夹并在mixin文件中创建一个mixin.js文件： //抛出混入对象，方便外部访问 mixin.js export const mixin={ data(){ return { number:1 } } } 可以看到我们在混入对象中创建了一个变量，是的，混入对象跟Vue实例的格式是一样的； 然后我们可以将mixin.js引入到我们的page1.vue和page2.vue中 // page1.vue //这里读的值其实是mixin的值，因为这个时候mixin已经混入到vue实例中了 page1的值是: //引入mixin.js import {mixin} from \"./mixin/mixin\" export default { //这里注意：属性名为mixins，值为数组类型 mixins:[mixin], data () { return { } }, } // page2.vue page2的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } } } 这个时候我们的混入对象已经成功混入到Vue实例中，你们可以点击看看效果，是可以正常运行并且能读取到值的； 现在我们来修改page1.vue的代码： //page1.vue page2的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } } } page2不变，再运行可以发现，我们的page1.vue中的值是执行了mounted，所以产生了自增 由此，我们可以知道mixin混入对象的变量是不会共享的；也就是你page1发生了变化，并不会通知mixin进行实时刷新数据，发生的变化只会在page1.vue中生效，不影响其他组件； 现在我们修改mixin.js和page1.vue中的代码： // mixin.js export const mixin={ data(){ return { number:1 } }, created(){ console.log(\"mixin混入对象\") } } // page1.vue page1的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } }, created(){ console.log(\"这里是page1\"); } } 这个时候我们再运行可以发现控制台输出是这个样子的： 是的，mixin混入对象中声明了：如果是同名钩子函数将合并为一个数组，因此都被调用，但是混入对象的钩子将在自身实例钩子之前触发； 值为对象的选项，例如methods,components等如果变量名和mixin混入对象的变量名发生冲突，将会以组件优先并进行递归合并，相当于组件数据直接覆盖了mixin中的同名数据； 我们可以修改代码mixin.js和page1.vue // mixin.js export const mixin={ data(){ return { number:1 } }, methods:{ demo1(){ console.log(\"mixin混入对象\") } } } //page1.vue page1的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { number:10 } }, mounted(){ this.demo1(); }, methods:{ demo1(){ console.log(\"这里是page1\"); } } } 运行代码我们可以很清晰的看到都是执行我们组件内的值； 因为在vue中我们在实例中声明变量也是通过键值对的形式来声明的，其实也是一个对象； 全局混入 全局混入我们只需要把mixin.js引入到main.js中，然后将mixin放入到Vue.mixin()方法中即可； // main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router.js' import mixin from \"./mixin/mixin.js\" Vue.config.productionTip = false Vue.mixin(mixin) /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '' }) 是的，全局混入更为便捷，我们将不用在子组件声明，全局混入将会影响每一个组件的实例，使用的时候需要小心谨慎；这样全局混入之后，我们可以直接在组件中通过this.变量/方法来调用mixin混入对象的变量/方法； 很多同学可能看到这里会有一些疑问，这不就跟Vuex差不多嘛，其实不是的： mixin混入对象和Vuex的区别： Vuex是状态共享管理，所以Vuex中的所有变量和方法都是可以读取和更改并相互影响的； mixin可以定义公用的变量或方法，但是mixin中的数据是不共享的，也就是每个组件中的mixin实例都是不一样的，都是单独存在的个体，不存在相互影响的； mixin混入对象值为函数的同名函数选项将会进行递归合并为数组，两个函数都会执行，只不过先执行mixin中的同名函数； mixin混入对象值为对象的同名对象将会进行替换，都优先执行组件内的同名对象，也就是组件内的同名对象将mixin混入对象的同名对象进行覆盖； Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-15 14:50:50 "},"technology/7道javascript题，让你理解基本的javascript.html":{"url":"technology/7道javascript题，让你理解基本的javascript.html","title":"7道javascript题，让你理解基本的javascript","keywords":"","body":"7道javascript题，让你理解基本的javascript 如果你符合JavaScript高级开发人员的资格，在编码面试中很有可能会被问到一些刁钻的问题。 1. 意外的全局变量 问题 在以下代码中，typeof a和typeof b的值分别是什么： function foo() { let a = b = 0; a++; return a; } foo(); typeof a; // => ???typeof b; // => ??? 答案 让我们仔细看看第2行：let a = b = 0。这个语句确实声明了一个局部变量a。但是，它确实声明了一个全局变量b。 在foo()作用域或全局作用域中都没有声明变量 b ”。因此JavaScript将表达式 b = 0 解释为 window.b = 0。 b是一个偶然创建的全局变量。 在浏览器中，上述代码片段相当于: function foo() { let a; window.b = 0; a = window.b; a++; return a; } foo(); typeof a; // => 'undefined' typeof window.b; // => 'number' typeof a是 'undefined'。变量a仅在 foo()范围内声明，在外部范围内不可用。 typeof b等于'number'。b是一个值为 0的全局变量。 2. 数组 length 属性 问题 clothes[0] 的值是什么： const clothes = ['jacket', 't-shirt']; clothes.length = 0; clothes[0]; // => ??? 答案 数组对象的 length 属性有一个 特殊的行为: 减少length属性的值有一个副作用，就是会删除索引位于新旧长度值之间的元素。 因为 length的这种行为，当JavaScript执行clothes.length = 0 时，数组 clothes 中的所有项都被删除了。 clothes[0] 是undefined，因为 clothes 数组被清空了。 3. 鹰眼测试 问题 numbers 数组的内容是什么： const length = 4; const numbers = []; for (var i = 0; i ??? 答案 让我们仔细看看出现在左花括号{前面的分号; ： 很容易忽略这个分号，而它创建了一个空语句。空语句是不做任何事情的语句。 for() 在空语句（什么也不做）上循环了 4 次，忽略了实际上往数组里添加元素的代码块{ numbers.push(i + 1); }。 上述代码等同于： const length = 4; const numbers = []; var i; for (i = 0; i [5] for()递增变量i直到4。然后JavaScript 进入代码块 { numbers.push(i + 1); }，将4 + 1 添加 到numbers数组中。 这样 numbers 就是 [5]. 4. 自动插入分号 问题 function arrayFromValue(item) { return [items]; } arrayFromValue(10); // => ??? 答案 很容易忽略return关键字和[items]表达式之间的换行。 换行使JavaScript自动在return和[items]表达式之间插入一个分号。 这里有一段等价的代码，它在return后插入分号： function arrayFromValue(item) { return; [items]; } arrayFromValue(10); // => undefined 函数中的 return; 导致它返回 undefined。 因此 arrayFromValue(10) 的值是 undefined。 5. 经典问题：坑爹的闭包 问题 以下脚本将会在控制台输出什么： let i; for (i = 0; i { console.log(i); } setTimeout(log, 100); } 答案 如果你之前没有听说过这个棘手的问题，你的答案很可能是0, 1 和 2，这是不正确的。当我第一次尝试解答它时，我的答案也是这样！ 执行这个代码段包含两个步骤。 步骤 1 for()迭代3次。在每次迭代过程中，都会创建一个新的函数log()，它捕获变量 i。然后setTimout()执行log()。 当for()循环完成时，i变量的值为3。 log()是一个捕获变量 i 的闭包，它在for()循环的外部作用域定义。重要的是要理解闭包从词法上捕获了变量i 。 步骤 2 第2步在 100 毫秒后发生： setTimeout()调用了队列中的3个log() 回调。log() 读取变量 i的当前值，即3，并记录到控制台3。 这就是为什么控制台输出3, 3 和3。 你知道怎样让代码输出 0, 1, 和 2吗？请在评论里写出你的方案。 6. 浮点数问题 问题 等号判断的结果是什么？ 0.1 + 0.2 === 0.3 // => ??? 答案 首先，我们看看0.1 + 0.2 的值： 0.1 + 0.2; // => 0.30000000000000004 0.1 和 0.2 的和 不完全等于 0.3，而是略大于 0.3。 由于浮点数在二进制中的编码机制，像浮点数的加法这样的操作会受到舍入误差的影响。 简单地说，直接比较浮点数是不精确的。 因此 0.1 + 0.2 === 0.3 是 false. 7. 变量提升 问题 如果在声明之前访问myVar和myConst会发生什么? myVar; // => ???myConst; // => ??? var myVar = 'value'; const myConst = 3.14; 答案 变量提升和暂时性死区是影响JavaScript变量生命周期的两个重要概念。 在声明之前访问 myVar 结果为undefined。一个被提升的var变量，在它的初始化之前，有一个 undefined的值。 但是，在声明之前访问myConst会抛出 ReferenceError。在声明行const myConst = 3.14之前，const 变量处于暂时死区。 NND，这几道题，我一直也没有啥留意的，要我首次做，应该挂的也比较居多。这次从简书上看到，就记录一下，涨涨知识。吼~~~~ Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-18 15:18:04 "},"technology/异步神器Async-await介绍与填坑.html":{"url":"technology/异步神器Async-await介绍与填坑.html","title":"异步神器Async-await介绍与填坑","keywords":"","body":"异步神器Async-await介绍与填坑 神，请好好研究一下async-await功能，接下来的业务需求中，用处巨巨巨巨大，请同我学习，我教你们。 请每一行每一句的去了解，并使用些方法。坑要认真的填，别被埋了 async - 定义异步函数 async 译：异步，是 Generator 函数的语法糖。该函数会返回一个promise对象，可以使用then方法添加回调函数，如果在函数内直接 return，Async会通过Promise.resolve()将其封装成Promise()对象，也可以通过.then添加回调函数 async 为异步函数，请牢记 ，如下面例子 async function pms() { return 'abc' } console.log(pms()) // [object Promise] { ... } 以上方法执行返回了一个promise对象，其执行等效于 async function pms() { return new Promise((resolve, reject) => { resolve('abc') }) } 在没有配合await时，我们可以调用promise的.then方法得到执行结果。当然也会有.catch方法 pms().then(res => { console.log(res) // 'abc' }).catch(e => { console.log('错误') }) 坑1：async的使用，有await,就一定要async，牛逼人都应该能记住 await - 暂停异步函数的执行 您历害了，你历害了，没有你怎么处理，await不错 await，即：async wait，旨在等待异步执行结束，使用于async函数内部。异步未执行结束，阻塞当前代码。嗯哼？阻塞！！！   与线程阻塞不同的是，await 的阻塞发生在 async 函数内部，可以理解为一个异步的阻塞。跟在await后的JS表达式，可以等待很多类型的事件，但初衷是用于等待Promise对象。如果await的对象是promise对象，则阻塞异步函数代码执行等待promise的resolve状态，如果是同步执行的表达式则立即执行。 async/await的使用 function asyncFunc(time) { return new Promise((resolve, reject) => { setTimeout(() => { // 用setTimeout模拟异步 resolve('async result') }, time) }) } function normalFunc() { console.log('normal result') } async function awaitDemo() { await normalFunc() // 执行立即打印 normal result const res = await asyncFunc(1000) console.log(res) // 执行1s后打印 ‘async result’ } awaitDemo() // 执行 以上的例子比较常规，再看看下面这个例子 async function func() { console.log('123') } async function run() { const res = await func() console.log(res) // 123 } run() 该例子中，func看似一个普通函数，但经async定义后，会返回一个promise对象，此时的await等待的就是该promise对象的resolve参数，即123。 对比上一个例子中的normalFunc，主要有两个理解点 （1）增加了async的普通函数变成了一个异步函数，await等待的对象为promise对象，返回resolve参数 （2）await可以等待任何东西，如果等待的是普通内容，则直接返回该内容 【填坑1】异常处理 请用try-catch处理异常内容 细心的你应该已经发现，await 返回的是promise的resolve参数，但对于catch却没有实际的处理。那当我们的请求发生异常时，该怎么办？答案是使用try-catch，在Promise中的.catch()分支会流入catch中 function asyncFunc(time) { return new Promise((resolve, reject) => { setTimeout(() => { // 用setTimeout模拟异步 reject('promise reject') }, time) }) } // 为了处理Promise.reject 的情况我们应该将代码块用 try catch 捕获一下 async function awaitDemo() { try { const res = await asyncFunc(1000) console.log(res) } catch (err) { console.log(err.message || 'Uncatch Error') } } awaitDemo() // 如果没有使用try-catch，执行会报错 坑1很重要，请认识注重异常处理方式 【填坑2】并行请求 对于一个真实的业务需求，通常会有多个异步请求需要同时执行，如获取左侧目录树，和登录账户的用户信息等。因await遇到异步会阻塞，当一个async函数内有多个异步函数需要调用时，就会出现相互等待的现象。天哪，“异步” 变成了 “同步”了，这不是我们所希望的 function asyncFunc() { return new Promise((resolve, reject) => { setTimeout(() => { resolve('request done') }) }) } async function bugDemo() { await asyncFunc() await asyncFunc() await asyncFunc() console.log('finish') } 历害了，可能用paomise.all() 把异步变成同步 以上代码正常执行了，没有报出异常，但仔细观察控制台 timeline 可以发现，三个函数是同步顺序执行的，其罪魁祸首就是await的等待机制。那怎么解决这个问题？   其实async-await 只是promise的语法糖，但其并不能代替Promise，从对异常的处理上就可以看出，还需要引入try-catch ，本问题是另一个体现。解决办法需要使用promise的.all() promise.all( iterable )，当所有请求都为resolve时，返回resolve状态 async function correctDemo() { const f1 = asyncFunc() const f2 = asyncFunc() const f3 = asyncFunc() await Promise.all([f1, f2, f3]); console.log('finish') } 牛逼吧，要用Promise.all来处理同步，什么叫同步，就是更好的使用咯。 【填坑3】await必须在async的上下文中 await 并不只是使用在async 函数中即可，还必须在asyn函数的上下文中 // 虽在async函数里使用，但在forEach上下文中，异常 async function errorDemo() { [1, 2, 3, 4, 5].forEach(item => { await item; }); } errorDemo() // SyntaxError: await is only valid in async function // await 必须在async函数的上下文中 async function correctDemo() { let arr = [1, 2, 3, 4, 5]; for (let i = 0; i 理解没，我感觉到，本人好像理解，对，不是好像，是己经掌握 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-27 10:00:35 "},"technology/JavaScript数组求并集，交集和差集.html":{"url":"technology/JavaScript数组求并集，交集和差集.html","title":"JavaScript数组求并集，交集和差集","keywords":"","body":"JavaScript数组求并集，交集和差集 现有两数组a = [1, 2, 3]，b = [2, 4, 5]，求a，b数组的并集，交集和差集。 1、ES7方法 ES7新增了一个Array.prototype.includes的数组方法，用于返回一个数组是否包含指定元素，结合filter方法。 // 并集 let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5] // 交集 let intersection = a.filter(v => b.includes(v)) // [2] // 差集 let difference = a.concat(b).filter(v => a.includes(v) && !b.includes(v)) // [1,3] 2、ES6方法 ES6中新增的一个Array.from方法，用于将类数组对象和可遍历对象转化为数组。只要类数组有length长度，基本都可以转化为数组。结合Set结构实现数学集求解。 let a = [1, 2, 3] console.log(a) let b = [2, 4, 5] let aSet = new Set(a) let bSet = new Set(b) // 并集 let union = Array.from(new Set(a.concat(b))) // [1,2,3,4,5] console.log(union) // 交集 let intersection = Array.from(new Set(a.filter(v => bSet.has(v)))// [2] ) // 差集 let differenceNew = Array.from(new Set(a.concat(b).filter(v => aSet.has(v) && !bSet.has(v))) [1,3] ) console.log(differenceNew) ES5方法 ES5可以利用filter和indexOf进行数学集操作，但是，由于indexOf方法中NaN永远返回-1，所以需要进行兼容处理。 01不考虑NaN(数组中不含NaN) var a = [1,2,3]; var b = [2,4,5]; // 并集 var union = a.concat(b.filter(function(v) { return a.indexOf(v) === -1})) // [1,2,3,4,5] // 交集 var intersection = a.filter(function(v){ return b.indexOf(v) > -1 }) // [2] // 差集 var difference = a.filter(function(v){ return b.indexOf(v) === -1 })// [1,3] console.log(union) console.log(intersection) console.log(difference) 02考虑NaN var a = [1, 2, 3, NaN]; var b = [2, 4, 5]; var aHasNaN = a.some(function (v) { return isNaN(v) }) var bHasNaN = b.some(function (v) { return isNaN(v) }) // 并集 var union = a.concat(b.filter(function (v) { return a.indexOf(v) === -1 && !isNaN(v) })).concat(!aHasNaN & bHasNaN ? [NaN] : []) // [1,2,3,4,5,NaN] // 交集 var intersection = a.filter(function (v) { return b.indexOf(v) > -1 }).concat(aHasNaN & bHasNaN ? [NaN] : []) // [2] // 差集 var difference = a.filter(function (v) { return b.indexOf(v) === -1 && !isNaN(v) }).concat(aHasNaN && !bHasNaN ? [NaN] : [])//1,3,NaN console.log(union) console.log(intersection) console.log(difference) filter完成数组去重 var r; var arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index; }); alert(r); // 去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-25 14:13:31 "},"technology/JavaScript之防抖Debounce和节流Throttle.html":{"url":"technology/JavaScript之防抖Debounce和节流Throttle.html","title":"JavaScript之防抖Debounce和节流Throttle","keywords":"","body":"JavaScript之防抖（Debounce）和节流（Throttle） 一、背景 防抖和节流是两种不同的控制一个函数执行次数的方法，其目的都是为了节约计算机资源。 当我们操作DOM的时候，加上节流或者防抖就非常有必要，因为众所周知，操作DOM的开销是非常大的，所以要尽可能减少DOM操作次数。 // html Number of scroll events Reset 0 //css body { background: #444444; color: white; font: 15px/1.51 system, -apple-system, \".SFNSText-Regular\", \"San Francisco\", \"Roboto\", \"Segoe UI\", \"Helvetica Neue\", \"Lucida Grande\", sans-serif; margin:0 auto; max-width:600px; padding:20px; min-height:1000vh; /* 100 times viewport height */ } #counter { position:fixed; top:100px; left:40%; font-size:50px; } .reset { color:white; text-decoration:none; border:1px solid white; padding:10px 20px; background:rgba(0,0,0,0.1); } //js var i = 0; var $counter = $('#counter'); $(document).ready(function(){ $(document).on('scroll', function(){ $counter.html(i); i++; }); }); $('.reset').on('click', function(){ $counter.html(''); i = 0; }) 当鼠标滚动或者拖拽的时候可以轻易地每秒触发30个事件，而且在移动端慢速滚动可以达到每秒100次，要是这么短的时间内每次都触发一个或多个函数，那浏览器应该会卡死崩溃的，所以这就引出了防抖和节流。 二、防抖（Debounce） 例子： Trigger area Reset Raw events over time Debounced events 400ms, trailing body { background: #444444; color: white; font: 15px/1.51 system, -apple-system, \".SFNSText-Regular\", \"San Francisco\", \"Roboto\", \"Segoe UI\", \"Helvetica Neue\", \"Lucida Grande\", sans-serif; margin:0 auto; max-width:700px; padding:20px; } .events{ padding:0px 20px 10px 20px; height: 23px; } .events span { height:17px; width:6px; display:inline-block; border-right:1px solid #111; } .events span:last-of-type { border:2px solid black; border-bottom: 4px solid #AAA; border-top: 0px; margin-bottom:-17px; margin-left:-2px; } h2 { margin:10px 0 5px 0; clear:both; font-weight: normal; font-size:14px; padding:6px 20px; } .trigger-area { margin: 0; display:inline-block; width: 200px; height:50px; border: 1px solid #5ed1ff; padding: 28px 0 0 0; text-align: center; background-color: transparent; cursor:pointer; font-size:17px; -webkit-user-select: none; /* Chrome / Safari */ -moz-user-select: none; /* Firefox all */ -ms-user-select: none; /* IE 10+ */ user-select: none; /* Likely future */ } .trigger-area.active { background:#2F5065; } .clickme:hover, .clickme:active{ background-color: #333; } .clickme:active{ padding: 4px 5px; } .reset { display:inline-block; width: 120px; padding: 10px 0 0 0; text-align: center; font-size:14px; cursor:pointer; color:#eee; } .visualizations { margin-top:10px; background:rgba(0,0,0,0.2); } .details { font-size:13px; color:#999; } /* stating the obvious: color0 represents our empty color */ .color0 { transparent} .color1 { background-color: #FFE589} .color2 { background-color: #B9C6FF} .color3 { background-color: #99FF7E} .color4 { background-color: #FFB38A} .color5 { background-color: #A5FCFF} .color6 { background-color: #FF8E9B} .color7 { background-color: #E3FF7E} .color8 { background-color: #FFA3D8} .color9 { background-color: #5ca6ff} .color10 { background-color: #9BFFBB} $(document).ready(function(){ var $rawDiv = $('#raw-events'), $debounceDiv = $('#debounced-events'), $triggerArea = $('.trigger-area'), initialized = false, frequency = 100, barLength = 0, globalColor = 2, colorNeedChange = false, interval_id, rawColor = 0, debounceColor = 0, maxBarLength = 87; var drawDebouncedEvent = _.debounce(function(div){ debounceColor = globalColor; }, frequency*4, {leading:false, trailing:true}); var changeDebouncedColor = _.debounce(function(div){ // Change colors, to visualize easier the \"group of events\" that is reperesenting this debounced event globalColor++; if (globalColor > 9){ globalColor = 2; } }, frequency*4, {leading:false, trailing:true}); function draw_tick_marks(){ // every x seconds, draw a tick mark in the bar interval_id = setInterval(function(){ barLength++; $rawDiv.append(''); $debounceDiv.append(''); rawColor = 0; // make it transparent again debounceColor = 0; // make it transparent again if (barLength > maxBarLength){ clearInterval(interval_id); } }, frequency); }; // Track Mouse movement or clicks for mobile $triggerArea.on('click mousemove', function (){ if (!initialized) { initialized = true; draw_tick_marks(); $(this).addClass('active'); } rawColor = globalColor; drawDebouncedEvent(); changeDebouncedColor(); }); $('.reset').on('click', function(){ initialized = false; $triggerArea.removeClass('active'); $rawDiv.empty(); $debounceDiv.empty(); barLength = 0; clearInterval(interval_id); }); }); 具体实现 function debounce(func,delay) { let timer; return function(...args) { if (timer) { clearTimeout(timer); } timer = setTimeout(() => { func.apply(this,arguments); },delay) } } Lodash中实现 _.debounce 和 _.throttle 的功能很全面，可以直接使用，其中的 throttle函数是使用 _.debounce 新增 maxWait` 选项来实现的 Resize实例 // Based on http://www.paulirish.com/2009/throttled-smartresize-jquery-event-handler/ $(document).ready(function(){ var $win = $(window); var $left_panel = $('.left-panel'); var $right_panel = $('.right-panel'); function display_info($div) { $div.append($win.width() + ' x ' + $win.height() + ''); } $(window).on('resize', function(){ display_info($left_panel); }); $(window).on('resize', _.debounce(function() { display_info($right_panel); }, 400)); }); 输入验证实例 $(document).ready(function(){ var $statusKey = $('.status-key'); var $statusAjax = $('.status-ajax'); var intervalId; // Fake ajax request. Just for demo function make_ajax_request(e){ var that = this; $statusAjax.html('That\\'s enough waiting. Making now the ajax request'); intervalId = setTimeout(function(){ $statusKey.html('Type here. I will detect when you stop typing'); $statusAjax.html(''); $(that).val(''); // empty field },2000); } // Event handlers to show information when events are being emitted $('.autocomplete') .on('keydown', function (){ $statusKey.html('Waiting for more keystrokes... '); clearInterval(intervalId); }) // Display when the ajax request will happen (after user stops typing) // Exagerated value of 1.2 seconds for demo purposes, but in a real example would be better from 50ms to 200ms $('.autocomplete').on('keydown', _.debounce(make_ajax_request, 1300)); }); 当用户输入并且发起Ajax请求的时候，_.debounce可以用来实现防抖，比如间隔2秒未检测到用户输入才发起请求。 三、节流（Throttle） 具体实现 -- 使用定时器 var throttle = function(func, delay) { var timer = null; return function() { if (!timer) { timer = setTimeout(function() { func.apply(this,arguments); timer = null; },delay); } } } 另一种定时器写法： let isAllow = true; function throttle() { let fun = function() { if (!isAllow) return; let timer = setTimeout(() => { console.log(\"throttle\"); clearTimeout(timer); timer = null; isAllow = true; },1000); }; fun()； } 二者的区别是后者使用了isAllow标志位来判断是否需要执行函数。 滚动条实例 一个十分常见的例子，当用户的鼠标滚动的时候，检查鼠标位置离底部的距离，当接近底部时，发起Ajax请求。 Infinite scrolling throttled Block 1 Block 2 Block 3 Block 4 body { background: #444444; color: white; font: 15px/1.51 system, -apple-system, \".SFNSText-Regular\", \"San Francisco\", \"Roboto\", \"Segoe UI\", \"Helvetica Neue\", \"Lucida Grande\", sans-serif; margin:0 auto; max-width:600px; padding:20px; } .item { border:4px solid white; height:120px; width:100%; margin-bottom:50px; background:#333; padding:20px; } .color-1 { border-color: #9BFFBB} .color-2 { border-color: #B9C6FF} .color-3 { border-color: #FFA3D8} .color-4 { border-color: #FF8E9B} // Very simple example. // Probably you would want to use a // full-featured plugin like // https://github.com/infinite-scroll/infinite-scroll/blob/master/jquery.infinitescroll.js $(document).ready(function(){ // Check every 200ms the scroll position $(document).on('scroll', _.throttle(function(){ check_if_needs_more_content(); }, 300)); function check_if_needs_more_content() { pixelsFromWindowBottomToBottom = 0 + $(document).height() - $(window).scrollTop() -$(window).height(); // console.log($(document).height()); // console.log($(window).scrollTop()); // console.log($(window).height()); //console.log(pixelsFromWindowBottomToBottom); if (pixelsFromWindowBottomToBottom requestAnimationFrame requestAnimationFrame是另一种限制函数执行次数的方式，可以认为与_.throttle类似，但是其拥有更高的准确度，因为其本身就是为了更好的精确度而生的原生API。 requestAnimationFrame的优点 致力于60fps（16ms每帧），自己可以决定最好的渲染时间。 简单且标准的原生API，不太容易改变，减少维护成本。 requestAnimationFrame的缺点 需要手动开始或取消rAFs，.debounce 或 .throttle则不需要。 如果tab没有激活，则不会执行，即使触发 Ascroll, mouse 或者 keyboard 等事件也不行. 不支持 IE9, Opera Mini 和 老版本 Android. 不支持node.js，所以不能在服务端使用。 requestAnimationFrame实例 与_.throttle相比，同时设置 16ms， 相同的性能环境下，rAF 可以在更复杂的情况下拥有更好的结果。 四、结论 一般来说，如果你的JavaScript函数是直接绘制或者动画某些属性，那么可以使用requestAnimationFrame，在需要重新计算元素位置的地方使用。 需要发起Ajax请求，或者决定是否增加或删除一个类的时候，可以考虑使用_.debounce 或者_.throttle 。 debounce: 在事件被触发x秒后再执行回调，如果在这x秒内又被触发，则重新计时。 throttle: 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 requestAnimationFrame: 节流的另外一种选项，在函数重新计算或者渲染元素时，需要平滑过渡或者动画的时候使用。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-18 10:00:05 "},"technology/Vue.set和this.$set应用的场景.html":{"url":"technology/Vue.set和this.$set应用的场景.html","title":"Vue.set和this.$set应用的场景","keywords":"","body":"Vue.set()和this.$set()应用的场景 背景：在vue中改变对象的属性值或者通过索引改变数组时，对应修改的字段不会重新在页面渲染。 例如： const vueInstance = new Vue({ data: { arr: [1, 2], obj1: { a: 3 } } }); vueInstance.$data.arr[0] = 3; // 页面不会重新渲染 vueInstance.$data.obj1.b = 3; // 页面不会重新渲染 经过查看官方文档发现这部分说明如下： Vue.set()向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。 它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = 'hi') 所以按照官方的写法应该是： Vue.set(vueInstance.$data.arr, 0, 3); // 这样操作数组可以让页面重新渲染 vueInstance.$set(vueInstance.$data.arr, 0, 3); // 这样操作数组也可以让页面重新渲染 Vue.set(vueInstance.$data.obj1, b, 3); // 这样操作对象可以让页面重新渲染 vueInstance.$set(vueInstance.$data.obj1, b, 3); // 这样操作对象也可以让页面重新渲染 Vue.set()和this.$set()实现原理 是时候看一波这两个api的源码了，我们先来看看Vue.set()的源码： import { set } from '../observer/index' ... Vue.set = set ... 再来看看this.$set()的源码： import { set } from '../observer/index' ... Vue.prototype.$set = set ... 发现这两个api的实现原理基本一模一样，都是使用了set函数。 set函数是从 ../observer/index 文件中导出的，区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。 数组的实现原理 继续源码： if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } 首先if判断当前target是不是数组，并且key的值是有效的数组索引。 然后将target数组的长度设置为target.length和key中的最大值，这里为什么要这样做呢?是因为我们可能会进行下面这种骚操作： arr1 = [1,3]; Vue.set(arr1,10,1) // 如果不那样做，这种情况就会出问题 接着向下看，我们发现这里直接调用了target.splice(key, 1, val)，在前面我们说过调用arrayMethods提供的push、pop等7个方法可以导致页面重新渲染，刚好splice也是属性arrayMethods提供的7个方法中的一种。 总结一下Vue.set数组实现的原理： 其实Vue.set()对于数组的处理其实就是调用了splice方法，是不是发现其实很简单~~ 对象的实现原理 续看源码： if (key in target && !(key in Object.prototype)) { target[key] = val return val } 这里先判断如果key本来就是对象中的一个属性，并且key不是Object原型上的属性。说明这个key本来就在对象上面已经定义过了的，直接修改值就可以了，可以自动触发响应。 注意：对于新增的对象属性不会重新渲染，这也刚好解释了我们使用 vueInstance.$data.obj1.b = 3; 的时候为什么页面不会重新渲染，因为这里的属性b不是对象的已有属性，也就是说属性b没有进行过依赖收集，所以才会导致修改属性b的值页面不会重新渲染。 继续看源码： defineReactive(ob.value, key, val) ob.dep.notify() return val 这里其实才是vue.set()真正处理对象的地方。defineReactive(ob.value, key, val)的意思是给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染。 ob.dep.notify()这句代码的意思是触发当前的依赖（这里的依赖依然可以理解成渲染函数），所以页面就会进行重新渲染。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-27 15:31:42 "},"technology/vue高级技巧.html":{"url":"technology/vue高级技巧.html","title":"vue高级技巧","keywords":"","body":"vue 高级技巧 1.css 局部样式 vue 中style样式添加scoped属性表示它的样式只作用于当前组件，样式私有化。 但是当前组件的根组件会受到父组件样式的影响。（比如父组件有个.box{background:red}, 如果子组件即当前组件的根组件类名也为box，那背景也会为red） 其中渲染的原理： 给HTML的DOM节点添加一个不重复的data属性 来表示唯一性 在对应的css选择器末尾添加一个当前组件的data属性选择器来私有化 如果使用了scoped属性后，想让组件内部样式被外部控制，只需要css添加 deep属性即可 .text-box { /deep/ input { width: 166px; text-align: center; } } 2. Vue.filter 全局过滤器 过滤器的目的主要是为了对数据进行转换 computed计算属性也可以转换，但是computed不能接受参数，只能针对某一个Vue内部属性进行转换，但是filter可以接受参数。 注册 全局过滤器 Vue.filter('globalFilter', value=>{....}) 组件过滤器 filters:{ testFilters: value=>{...} } 注：一直不怎么会用全局过滤器，有关全局的都不清楚，这要重点研究一下这里的知识 使用 在双花括号插值 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-19 15:54:47 "},"technology/npm常用命令大全.html":{"url":"technology/npm常用命令大全.html","title":"npm常用命令大全","keywords":"","body":"npm常用命令大全 1.查看版本 npm -v 2.安装模块 全局安装 npm install -g 本地安装 npm install 在项目中安装保存到package.json中 npm install --save-dev 3.查看安装信息 查看所有安装模块 npm list -g 查看某个模块 npm list 4.卸载模块 npm uninstall 5.更新模块 npm update 6.搜索模块 npm search 7.清空本地缓存 npm cache clear 附： 使用淘宝 NPM 镜像 大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。 淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用 cnpm 命令来安装模块了 cnpm install Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-12-26 14:49:00 "},"technology/7个有用的Vue开发技巧.html":{"url":"technology/7个有用的Vue开发技巧.html","title":"7个有用的Vue开发技巧","keywords":"","body":"7个有用的Vue开发技巧 7个有用的Vue开发技巧，好好理解，感到还不错，非常好 1 状态共享 随着组件的细化，就会遇到多组件状态共享的情况，Vuex当然可以解决这类问题，不过就像Vuex官方文档所说的，如果应用不够大，为避免代码繁琐冗余，最好不要使用它，今天我们介绍的是vue.js 2.6新增加的Observable API ，通过使用这个Api我们可以应对一些简单的跨组件数据状态共享的情况。 如下这个例子，我们将在组件外创建一个store，然后在App.vue组件里面使用store.js提供的store和mutation方法，同理其它组件也可以这样使用，从而实现多个组件共享数据状态。 首先创建一个store.js，包含一个store和一个mutations，分别用来指向数据和处理方法。 import Vue from \"vue\"; export const store = Vue.observable({ count: 0 }); export const mutations = { setCount(count) { store.count = count; } }; 然后在App.vue里面引入这个store.js，在组件里面使用引入的数据和方法 count: +1 -1 import { store, mutations } from \"./store\"; export default { name: \"App\", computed: { count() { return store.count; } }, methods: { setCount: mutations.setCount } }; 2 长列表性能优化 我们应该都知道vue会通过object.defineProperty对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要vue来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止vue劫持我们的数据呢？可以通过object.freeze方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。 export default { data: () => ({ users: {} }), async created() { const users = await axios.get(\"/api/users\"); this.users = Object.freeze(users); } }; 另外需要说明的是，这里只是冻结了users的值，引用不会被冻结，当我们需要reactive数据的时候，我们可以重新给users赋值。 export default { data: () => ({ users: [] }), async created() { const users = await axios.get(\"/api/users\"); this.users = Object.freeze(users); }, methods:{ // 改变值不会触发视图响应 this.users[0] = newValue // 改变引用依然会触发视图响应 this.users = newArray } }; 3 去除多余的样式 随着项目越来越大，书写的不注意，不自然的就会产生一些多余的css，小项目还好，一旦项目大了以后，多余的css会越来越多，导致包越来越大，从而影响项目运行性能，所以有必要在正式环境去除掉这些多余的css，这里推荐一个库purgecss，支持CLI、JavascriptApi、Webpack等多种方式使用，通过这个库，我们可以很容易的去除掉多余的css。 Hello Vanilla! We use Parcel to bundle this sandbox, you can find more info about Parcel here. body { font-family: sans-serif; } a { color: red; } ul { li { list-style: none; } } import Purgecss from \"purgecss\"; const purgecss = new Purgecss({ content: [\"**/*.html\"], css: [\"**/*.css\"] }); const purgecssResult = purgecss.purge(); 最终产生的purgecssResult结果如下，可以看到多余的a和ul标签的样式都没了 4 作用域插槽 利用好作用域插槽可以做一些很有意思的事情，比如定义一个基础布局组件A，只负责布局，不管数据逻辑，然后另外定义一个组件B负责数据处理，布局组件A需要数据的时候就去B里面去取。假设，某一天我们的布局变了，我们只需要去修改组件A就行，而不用去修改组件B，从而就能充分复用组件B的数据处理逻辑，关于这块我之前写过一篇实际案例。 这里涉及到的一个最重要的点就是父组件要去获取子组件里面的数据，之前是利用slot-scope，自vue 2.6.0起，提供了更好的支持 slot 和 slot-scope 特性的 API 替代方案。 比如，我们定一个名为current-user的组件： 父组件引用current-user的组件，但想用名替代姓（老外名字第一个单词是名，后一个单词是姓）： 这种方式不会生效，因为user对象是子组件的数据，在父组件里面我们获取不到，这个时候我们就可以通过v-slot 来实现。 首先在子组件里面，将user作为一个``元素的特性绑定上去： 之后，我们就可以在父组件引用的时候，给v-slot带一个值来定义我们提供的插槽 prop 的名字： 这种方式还有缩写语法，可以查看独占默认插槽的缩写语法，最终我们引用的方式如下： 相比之前slot-scope代码更清晰，更好理解。 5 属性事件传递 写过高阶组件的童鞋可能都会碰到过将加工过的属性向下传递的情况，如果碰到属性较多时，需要一个个去传递，非常不友好并且费时，有没有一次性传递的呢（比如react里面的{...this.props}）？答案就是v-bind和v-on。 举个例子，假如有一个基础组件BaseList，只有基础的列表展示功能，现在我们想在这基础上增加排序功能，这个时候我们就可以创建一个高阶组件SortList。 import BaseList from \"./BaseList\"; // 包含了基础的属性定义 import BaseListMixin from \"./BaseListMixin\"; // 封装了排序的逻辑 import sort from \"./sort.js\"; export default { props: BaseListMixin.props, components: { BaseList } }; 可以看到传递属性和事件的方便性，而不用一个个去传递 6 函数式组件 函数式组件，即无状态，无法实例化，内部没有任何生命周期处理方法，非常轻量，因而渲染性能高，特别适合用来只依赖外部数据传递而变化的组件。 写法如下： 在template标签里面标明functional 只接受props值 不需要script标签 (clicked = item)\" /> Clicked hero: import List from \"./List\"; export default { name: \"App\", data: () => ({ clicked: \"\" }), components: { List } }; 7 监听组件的生命周期 比如有父组件Parent和子组件Child，如果父组件监听到子组件挂载mounted就做一些逻辑处理，常规的写法可能如下： // Parent.vue // Child.vue mounted() { this.$emit(\"mounted\"); } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-12-03 17:22:23 "},"technology/18种CSS命名和书写规范.html":{"url":"technology/18种CSS命名和书写规范.html","title":"18种CSS命名和书写规范","keywords":"","body":"18种CSS命名和书写规范 选择器的命名规范 1.模块化命名 例如： 与布局相关的样式以“g”为开头。如“g-content”和“g-header”； 与挂钩相关的样式以“j”为开头。如“j-open”和“j-request”； 与元件相关的样式以“m”为开头。如“m-dropMenu”和“m-slider”； 与状态相关的样式以“s”为开头。如“s-current”和“s-selected”； 与工具相关的样式以“u”为开头。如“u-clearfix”和“u-ellipsis”。 “工具”是指与业务逻辑解耦的，能够重用的样式；“元件”是指自定义的可重用且可移植的基本网页元素；“挂钩”是指供JavaScript操纵的样式。 以上的说明只是举例，大家可以根据项目需求自定义开头的字符，这样做的目的是使CSS代码整洁易维护。 2.选择器皆为小写形式 推荐的写法： .g-first-header { line-height: 16px; } 不推荐的写法： .g-FirstHeader { line-height: 16px; } 3.每个选择器独占一列 除最后一个选择器外，其它每一列选择器均以逗号结尾。若用到兄弟元素选择器，则相关符号的左右两端均留出一个半角空格。 推荐的写法： // web前端开发学习Q-q-u-n： 731771211，分享学习的方法和需要注意的小细节，不停更新最新的教程和学习方法（详细的前端项目实战教学视频，PDF） .g-first-header, .g-second-header-1 > .g-second-header-2 { border: 2px solid #C3C3C3; } 不推荐的写法： .g-first-header, .g-second-header-1>.g-second-header-2 { border: 2px solid #C3C3C3; } 4.避开HTML标记 构建选择器时应尽量采用语义明确的类别名称，避开HTML标记，因为一旦HTML的结构产生更动，则与此对应的样式也就无效了。尽量将样式与结构分离，这样会使得阶层式样式表在日后更易被维护。 推荐的写法： .g-content .g-item { flex-basis: 20%; } 不推荐的写法： .g-content li { flex-basis: 20%; } 5.少用ID ID的唯一性注定了它所对应的元素的样式就是一次性的，无法重用，一旦HTML结构发生变化，套用ID的选择器就要随之修改。另一个重要的原因是：ID的权重值是最高的，这可能会导致日后添加的样式无法复写原先的样式。 推荐的写法： .g-special-content { height: 100px; width: 300px; } 不推荐的写法： #special-content { height: 100px; width: 300px; } 属性的书写规范 1.按顺序排列属性 每条规则下的属性在书写时，应按类别进行分组，其排列顺序如下： 位置：bottom、float、display、left、position、right、top和z-index等； 大小：height、margin、padding和width等； 版式：color、font、letter-spacing、line-height和text-align等； 背景：background等； 其它：animation和transition等。 2.缩写属性 有些属性是可以合在一块的，既精简代码，又便于阅读。 推荐的写法： .test-selector-1 { padding: 3px 5px; } 不推荐的写法： .test-selector-1 { padding-top: 3px; padding-right: 5px; padding-bottom: 3px; padding-left: 5px; } 3.去除小数开头的0 推荐的写法： .test-selector-2 { font-size: .5em; } 不推荐的写法： .test-selector-2 { font-size: 0.5em; } 4.缩写十六进位值 推荐的写法： .test-selector-3 { background-color: #0b0; } 不推荐的写法： .test-selector-3 { background-color: #00bb00; } 5.合理使用引号 对于“font-family”属性来说，我们通常会以引号夹住带有空格的字体名称，而对于不具备这些特征的一般字体来说，引号存在与否并不影响页面的显示效果。为了保证视觉上的统一，最大程度相容各种浏览器，建议你在所有字体名称的两端均加上引号。 推荐的写法： .test-selector-4 { font-family: \"Microsoft YaHei\", \"微软正黑体\", \"\\5b8b\\4f53\"; } 不推荐的写法： .test-selector-4 { font-family: \"Microsoft YaHei\", 微软正黑体, \\5b8b\\4f53; } 个别属性的值含有“url（）”字串，开发者需要往其中传入一个资源路径。请注意，在低版本的Internet Explorer中，路径中的空格有可能无法被辨识，导致资源无法被找到。为保险起见，不论路径中是否含有空格，你传入的路径两端最好都加上引号。 推荐的写法： //web前端开发学习Q-q-u-n： 731771211，分享学习的方法和需要注意的小细节，不停更新最新的教程和学习方法（详细的前端项目实战教学视频，PDF） .test-selector-5 { background-image: url(“../Images/BacPic.png”); } 不推荐的写法： .test-selector-5 { background-image: url(../Images/BackPic.png); } 6.避开！important “！important”会给日后的维护带来麻烦，使开发者难以查找样式问题。如果在书写时发现新样式无法复写旧样式。通常有两个原因：要么新样式写在了旧样式的前面，要么新样式对应的选择器的权重比旧样式的更低。针对后一种情况，只要增加新样式选择器的权重值就可以完全避开这个问题，无需用到“！important”。 推荐的写法： .test-selector-6 .test-selector-7 { font-size: 16px; } .test-selector-6 .test-selector-7 .test-selector-8 { font-size: 14px; } 不推荐的写法： .test-selector-6 .test-selector-7 { font-size: 16px; } .test-selector-8 { font-size: 14px !important; } 7.规范注释 在单列注释中，星号与内容之间留一个半角空格。 推荐的写法： /* 这是第一段注释文字。 */ // 这是第二段注释文字。复制代码 不推荐的写法： /*这里是一段注释文字。*/ //这是第二段注释文字。复制代码 在多列注释中，多个星号要排成一条线。星号与内容之间同样留一个半角空格。 推荐的写法： /** * 这里是一段注释文字。 * 这是第二段注释文字。 */ 不推荐的写法： /** *这里是一段注释文字。 *这是第二段注释文字。 */ 在文档注释中，除了要按照多列注释的写法以外，还要用标识符来说明文档中的某一部分，标识符后的冒号右侧与说明文字之间留一个半角空格。 推荐的写法： /** * @name: 文件名； * @description: 描述文字； * @author: 张三、李四； * @update: 2018年12月19日。 */ 不推荐的写法： /** * @name:文件名； * @description:描述文字； * @author:张三、李四； * @update:2018年12月19日。 */ 8.将标准属性置于底部 有些属性在部分浏览器中尚未完全标准化，每家浏览器开发商对这些属性的实现效果或许并不统一，因此目前需要在开头加入浏览器厂商的专有字符串。因此同一个属性需要写多次，但有一条需要注意：将不带前置标记的属性置于最下方。 推荐的写法： .test-selector-9 { opacity: 0; -webkit-transition: opacity 3s; -moz-transition: opacity 3s; -ms-transition: opacity 3s; -o-transition: opacity 3s; transition: opacity 3s; } 不推荐的写法： .test-selector-9 { opacity: 0; -webkit-transition: opacity 3s; transition: opacity 3s; -moz-transition: opacity 3s; -ms-transition: opacity 3s; -o-transition: opacity 3s; } 9.注意标点符号 每个属性独占一列。紧接样式属性的冒号，其后面要留一个半角空格。值以分号结尾。 推荐的写法： .test-selector-10 { opacity: .5; } 不推荐的写法： .test-selector-10 { opacity:.5 } 10.样式块间留一空行 样式选择器及其样式块与周遭内容要保留一空行以避免内容过于拥挤，妨碍寻找。 推荐的写法： .test-selector-11 { opacity: 0.5; } .test-selector-12 { font-size: 16px; } .test-selector-13 { overflow: hidden; } 不推荐的写法： .test-selector-11 { opacity: 0.5; } .test-selector-12 { font-size: 16px; } .test-selector-13 { overflow: hidden; } 11.将过长的内容折为若干列 同一属性的值不止一个或值过长时，以逗号分割这些值，每个逗号后添加一个空格，过长的值可以另起一列。 推荐的写法： //web前端开发学习Q-q-u-n： 731771211，分享学习的方法和需要注意的小细节，不停更新最新的教程和学习方法（详细的前端项目实战教学视频，PDF） .test-selector-14 { linear-gradient(135deg, deeppink 25%, transparent 25%) - 50px 0, linear-gradient(225deg, deeppink 25%, transparent 25%) - 50px 0, linear-gradient(315deg, deeppink 25%, transparent 25%), linear-gradient(45deg, deeppink 25%, transparent 25%); } 不推荐的写法： .test-selector-14 { linear-gradient(135deg, deeppink 25%, transparent 25%) - 50px 0, linear-gradient(225deg, deeppink 25%, transparent 25%) - 50px 0, linear-gradient(315deg, deeppink 25%, transparent 25%), linear-gradient(45deg, deeppink 25%, transparent 25%); } 12.避开CSS Hack 所谓“CSS Hack”，就是在样式表中加入少许特殊符号，让能够辨识不同符号的浏览器在同一个元素上计算出来的样式各不相同。出现CSS Hack的原因就在于老式的浏览器（诸如饱受诟病的Internet Explorer 6）对同一套样式表的计算结果与其它浏览器的并不相同，这就很有可能会造成版式上的错乱。因此在过去，我们通常要针对个别怪异的浏览器撰写有针对性的CSS。如width: 300px; _width: 200px;对其它浏览器来说，该选择器的宽度值应为300个像素，但IE 6能够辨识出底线，因此它计算出的宽度就是200个像素。 13.减少使用影响性能的属性 样式表中不要含有过多的滤镜表达式和repeat关键字等，这些属性会降低网页的渲染性能。若要重复背景图片，那么原图的宽高各不小于8px。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-12-06 13:39:00 "},"technology/5种常见函数的写法和调用方式.html":{"url":"technology/5种常见函数的写法和调用方式.html","title":"5种常见函数的写法和调用方式","keywords":"","body":"5种常见函数的写法和调用方式 函数在开发中随处可见，经常在开发中我们声明函数就使用了一两种就已经足够了，但是，对我这有梦想的码农来说，这显然是不够的，因此，总结整理了5中常见的声明方式和调用方式。 记录函数简单的写法，最基本功了，这个要学一下，不能忘记咯 1、函数声明（最常规写法） // 常规函数写法 function test() { console.log('这里是常规测试') } // 调用函数 test(); 2、函数表达式（匿名函数写法） // 匿名函数写法 function test() { console.log('这里是匿名函数测试') } // 调用函数 test(); 3、将方法作为一个对象 // 写法 var Test = { text1: function(){ console.log('这里是测试1') }, text2: function(){ console.log('这里是测试2') } } // 调用函数 Test.test1(); Test.test2(); 4、构造函数中给对象添加方法 (利用原型特性实现) // 构造函数写法 var Test = function(){} Test.prototype.way = function(){ console.log('这里是构造函数测试') } // 调用函数 var funname = new Test(); //创建对象 funname.way(); //调用对象属性 5、自执行函数 最前最后加括号 (function(){ console.log('测试内容1') }()) function外面加括号 (function(){ console.log('测试内容2') })() function前面加运算符，常见的是!与void。 !function(){ alert(1); }() void function(){ alert(2); }() Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-28 09:49:39 "},"technology/Vue 的父组件和子组件生命周期钩子函数执行顺序？.html":{"url":"technology/Vue 的父组件和子组件生命周期钩子函数执行顺序？.html","title":"Vue 的父组件和子组件生命周期钩子函数执行顺序？","keywords":"","body":" 这里是记录vue难点知识，请牢记，牢记.... Vue 的父组件和子组件生命周期钩子函数执行顺序？ Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted 子组件更新过程 父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated 父组件更新过程 父 beforeUpdate -> 父 updated 销毁过程 父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-12-02 17:56:18 "},"technology/JavaScript的优雅写法.html":{"url":"technology/JavaScript的优雅写法.html","title":"探讨JavaScript的优雅写法","keywords":"","body":"探讨JavaScript的优雅写法 用最合适的代码执行正确的逻辑， 句话意思是说，每一行代码要做到简洁，容易理解 「优雅」最直观的表现就是看起来舒服，要做到这一点不难，那就是代码书写讲究一个规范，可以是你最习惯的换行，最习惯的变量命名等等。不要一个几百行代码，书写习惯换了好几次。做到这一点，那么自己看起来就能舒服了。但是这仅仅是最基本的，公司中的项目往往是不止一个人开发，更多的是协同开发。代码仅仅是自己看起来舒服还不行，还要做到其他人看起来也舒服。要做到这一点，就需要把每个人书写的习惯统一起来，形成团队规范。 为了更好的写代码，提升自己，我忍了。看的文章越多，发现自己懂的越少。唉，为什么？求解！ 优雅写法，以前对于我来说是没有看回事的。写代码就是把整个模块切分为不同的模块，让每个模块更好的工作，并统一起来。看到这文章，也学学。 判断对内的「优雅」很简单，自己看代码能够毫不费劲就能理解逻辑，并且没有「乱糟糟」，「多余」的感觉。 具体的优雅写法实例 运算符处换行时，运算符在新行的行首。 在进行复杂的条件判断时，我们会使用到&&与||，这个使用过长的判断条件很容易让人心生厌恶，这个时候以一种漂亮的书写风格会更人让我们接受。 // good if (user.isAuthenticated() && user.isInRole('admin') && user.hasAuthority('add-admin') || user.hasAuthority('delete-admin') ) { // Code } var result = number1 + number2 + number3 + number4 + number5; // bad if (user.isAuthenticated() && user.isInRole('admin') && user.hasAuthority('add-admin') || user.hasAuthority('delete-admin')) { // Code } var result = number1 + number2 + number3 + number4 + number5; boolean 类型的变量使用 is 或 has 开头 这样做的好处是能一眼看出该变量就是一个布尔变量。 var isReady = false; var hasMoreCommands = false; 尽可能使用简洁表达式 在讲这个之前，先来复习一下JS中的数据类型及判断方式。 如上图所示，JS中的数据类型分为基本数据类型和引用数据类型，引用数据类型一般也被直接叫做对象。对象可以看做是一个复合数据类型，我们可以用它来组装其他数据类型。其中被官方组装好的也是用的很广泛的主要是四种：Array(数组)，Function(函数)，RegExp(正则)和Date(日期)。 那么在使用 if else时，对于条件的判断，我们尽可能使用简洁表达式： // 字符串为空 // good if (!name) { // ...... } // bad if (name === '') { // ...... } // 字符串非空 // good if (name) { // ...... } // bad if (name !== '') { // ...... } // 数组非空 // good if (collection.length) { // ...... } // bad if (collection.length > 0) { // ...... } // 布尔不成立 // good if (!notTrue) { // ...... } // bad if (notTrue === false) { // ...... } // null 或 undefined // good if (noValue == null) { // ...... } // bad if (noValue === null || typeof noValue === 'undefined') { // ...... } 如果函数或全局中的 else 块后没有任何语句，可以删除 else。 这个用的多，不用说，了解 // good function getName() { if (name) { return name; } return 'unnamed'; } // bad function getName() { if (name) { return name; } else { return 'unnamed'; } } 不要在循环体中包含函数表达式，事先将函数提取到循环体外 // good function clicker() { // ...... } for (var i = 0, len = elements.length; i 对循环内多次使用的不变值，在循环外用变量缓存 // good var width = wrap.offsetWidth + 'px'; for (var i = 0, len = elements.length; i 对有序集合进行顺序无关的遍历时，使用逆序遍历 解释:逆序遍历可以节省变量，代码比较优化。 var len = elements.length; while (len--) { var element = elements[len]; // ...... } 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检 测使用 == null 转换成 number 时，通常使用+ // good +str; //bad Number(str); 转换成 boolean 时，使用!! var num = 3.14; !!num; 属性访问尽量使用点语法 解释:如非必须使用[]的情况，则建议优先使用点语法。通常在 JavaScript 中声明的对象，属性 命名是使用 Camel 命名法，用 . 来访问更清晰简洁。 info.age; info['more-info']; 清空数组使用 .length=0 使用 let 和 const 定义变量，尽量不使用 var 解释:使用 let 和 const 定义时，变量作用域范围更明确。 使用 Object.keys 或 Object.entries 进行对象遍历 解释:不建议使用 for .. in 进行对象的遍历，以避免遗漏 hasOwnProperty 产生的错误。 使用&&或||代替三元表达式 逻辑与运算和逻辑或运算，实际上可以看做是条件运算的语法糖。同时JS 中的三元运算符，也可以看做是条件运算的简写方式。我们可以使用&&和||替代，这样减少了代码量，还便于理解。 // 不推荐 let userName = localStorage.userName ? localStorage.userName : 'admin' // 推荐 let userName = localStorage.userName || 'admin' JavaScript 复杂判断的优雅写法 前言: 之前项目中看到很多人代码里用了很多if-else语法，甚至达到了痴迷的地步，大大影响了代码的可读性和简洁度。正好最近看到网上一篇很好的对JavaScript中复杂判断的分析文章，这里整理一下分享给大家，希望能对各位有所帮助。 我就是一直用if-else，大哭，非常大哭。看来要经常研究怎么处理代码咯 if else 举例(一元判断) /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=>{ if(status == 1){ sendLog('processing') jumpTo('IndexPage') }else if(status == 2){ sendLog('fail') jumpTo('FailPage') }else if(status == 3){ sendLog('fail') jumpTo('FailPage') }else if(status == 4){ sendLog('success') jumpTo('SuccessPage') }else if(status == 5){ sendLog('cancel') jumpTo('CancelPage') }else { sendLog('other') jumpTo('Index') } } 通过代码可以看到这个按钮的点击逻辑：根据不同status做两件事情，sendLog和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场： 现在本人用的比较多的就是switch，发现还比较好用，哈哈哈哈 switch代替 /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=>{ switch (status){ case 1: sendLog('processing') jumpTo('IndexPage') break case 2: case 3: sendLog('fail') jumpTo('FailPage') break case 4: sendLog('success') jumpTo('SuccessPage') break case 5: sendLog('cancel') jumpTo('CancelPage') break default: sendLog('other') jumpTo('Index') break } } 听说还有更简单的写法，用的比较少，来来，我们一起看看 对象模式简写 const actions = { '1': ['processing','IndexPage'], '2': ['fail','FailPage'], '3': ['fail','FailPage'], '4': ['success','SuccessPage'], '5': ['cancel','CancelPage'], 'default': ['other','Index'], } /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=>{ let action = actions[status] || actions['default'], logName = action[0], pageName = action[1] sendLog(logName) jumpTo(pageName) } 上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。还有es6里面的Map对象简写: 下面就是map，这个用的比较多，不过正常都不是这样用，涨知识了 new Map() 这个功能要好好学学，理解一下 Map const actions = new Map([ [1, ['processing','IndexPage']], [2, ['fail','FailPage']], [3, ['fail','FailPage']], [4, ['success','SuccessPage']], [5, ['cancel','CancelPage']], ['default', ['other','Index']] ]) /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=>{ let action = actions.get(status) || actions.get('default') sendLog(action[0]) jumpTo(action[1]) } 这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？ 1.一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键。 2.一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。 3.你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份： if else 举例(二元判断) /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团 * @param {string} identity 身份标识：guest客态 master主态 */ const onButtonClick = (status,identity)=>{ if(identity == 'guest'){ if(status == 1){ //do sth }else if(status == 2){ //do sth }else if(status == 3){ //do sth }else if(status == 4){ //do sth }else if(status == 5){ //do sth }else { //do sth } }else if(identity == 'master') { if(status == 1){ //do sth }else if(status == 2){ //do sth }else if(status == 3){ //do sth }else if(status == 4){ //do sth }else if(status == 5){ //do sth }else { //do sth } } } 从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？ 我能说很不爽吧，救新解！！！！ Map实现 const actions = new Map([ ['guest_1', ()=>{/*do sth*/}], ['guest_2', ()=>{/*do sth*/}], ['guest_3', ()=>{/*do sth*/}], ['guest_4', ()=>{/*do sth*/}], ['guest_5', ()=>{/*do sth*/}], ['master_1', ()=>{/*do sth*/}], ['master_2', ()=>{/*do sth*/}], ['master_3', ()=>{/*do sth*/}], ['master_4', ()=>{/*do sth*/}], ['master_5', ()=>{/*do sth*/}], ['default', ()=>{/*do sth*/}], ]) /** * 按钮点击事件 * @param {string} identity 身份标识：guest客态 master主态 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团 */ const onButtonClick = (identity,status)=>{ let action = actions.get(`${identity}_${status}`) || actions.get('default') action.call(this) } 上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。 当然上述代码如果用Object对象来实现也是类似的： Object实现 const actions = { 'guest_1':()=>{/*do sth*/}, 'guest_2':()=>{/*do sth*/}, //.... } const onButtonClick = (identity,status)=>{ let action = actions[`${identity}_${status}`] || actions['default'] action.call(this) } 如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key： Map 规整写法 const actions = new Map([ [{identity:'guest',status:1},()=>{/*do sth*/}], [{identity:'guest',status:2},()=>{/*do sth*/}], //... ]) const onButtonClick = (identity,status)=>{ let action = [...actions].filter(([key,value])=>(key.identity == identity && key.status == status)) action.forEach(([key,value])=>value.call(this)) } 是不是又高级了一点点？ 这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。 探讨下各种情况 我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样： const actions = new Map([ [{identity:'guest',status:1},()=>{/* functionA */}], [{identity:'guest',status:2},()=>{/* functionA */}], [{identity:'guest',status:3},()=>{/* functionA */}], [{identity:'guest',status:4},()=>{/* functionA */}], [{identity:'guest',status:5},()=>{/* functionB */}], //... ]) 好一点的写法是将处理逻辑函数进行缓存： const actions = ()=>{ const functionA = ()=>{/*do sth*/} const functionB = ()=>{/*do sth*/} return new Map([ [{identity:'guest',status:1},functionA], [{identity:'guest',status:2},functionA], [{identity:'guest',status:3},functionA], [{identity:'guest',status:4},functionA], [{identity:'guest',status:5},functionB], //... ]) } const onButtonClick = (identity,status)=>{ let action = [...actions()].filter(([key,value])=>(key.identity == identity && key.status == status)) action.forEach(([key,value])=>value.call(this)) } 这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，那可以这样实现: const actions = ()=>{ const functionA = ()=>{/*do sth*/} const functionB = ()=>{/*do sth*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], //... ]) } const onButtonClick = (identity,status)=>{ let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`))) action.forEach(([key,value])=>value.call(this)) } 这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写: const actions = ()=>{ const functionA = ()=>{/*do sth*/} const functionB = ()=>{/*do sth*/} const functionC = ()=>{/*send log*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], [/^guest_.*$/,functionC], //... ]) } const onButtonClick = (identity,status)=>{ let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`))) action.forEach(([key,value])=>value.call(this)) } 也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-20 10:15:43 "},"life_exp/":{"url":"life_exp/","title":"生活类","keywords":"","body":"记录生活的点滴碎片 正所谓，书读百遍，其义自见 读书笔记的内容有如下： 内容介绍（即复述内容），主要是锻炼梳理主干内容的能力 语句摘抄与赏析，根据自己的喜好，有自己敏感的语句，并进行合理的赏析 提出问题，即自己在阅读中不理解的词语、句子、或者内容上的不懂的地方。 网上读书笔记流程： 每周周未制定好下一周的读书书目 读书书目中包含一本你不态想读的书 读书前，明确阅读目标并写下来 先通读一遍对书籍内容有一个大概的了解 重读做标记的地方，写出书我书籍的大纲 写书摘和评论 收获与行动 好记生不如烂笔头 这应该是我们从小就懂的道理，但是我们却往往在经历了学生时代以后就忘记了这句话 凡是值得读的书，至少须读两遍 - 第一遍快读，着眼于全文主旨与特色；第一遍慢读，须以批评态度衡量书的内容 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-27 09:41:24 "},"life_exp/程序员的发展方向.html":{"url":"life_exp/程序员的发展方向.html","title":"程序员的发展方向","keywords":"","body":"程序员的发展方向 技术+技术：架构或者某一领域的技术专家，这条路往往需要多年的开发经验，不管是架构还是技术专家，都需要你花费较多的精力去钻研，如果你认准你自己热爱技术的话走这条路还是比较适合的 技术+管理：项目管理，这是一条很多人都想走的路，因为模式比较简单，而且可以复制，作为项目的负责人你要把控整个项目的排期、开发的质量、线上的一些列问题、还有新人的培养，除此之外你还是整个项目对外的发言人，需要花费比较多的时间在和各部门沟通上，如果同学觉得自己性格还算比较外向的话，选择这条路的话还是比较适合的，但是需要注意的是项目经理的话意味着你必须熟悉自己所在的业务，不过这对于你以后往其他领域的发展会有些制约，所以现在很多公司多开始了轮岗制让开发人员熟悉多个部门的业务工作 技术+创业：这是一条很少有人走的路，而且就算选择了这条路也不意味着你能成功，选择创业你不仅仅需要过硬的技术能力，更要有敏锐的商业头脑和较高的情商，一般很少有同学会选择这条路，如果你选择了这条路请好好走下去，即便失败也会是你人生中不可多得一笔宝贵的记忆！ Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-20 15:08:14 "}}