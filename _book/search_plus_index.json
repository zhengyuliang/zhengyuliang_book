{"./":{"url":"./","title":"说明","keywords":"","body":"技术文章简介 总结所有技术文章，以后方像汇总，装订成书，并发表于网络 前端技术知识 技术知识主要来源于网络与我这段时间的学习所得，合适的时候本人也会按自己的思路去编写一定的技术文档 生活经验总结 经验总结而尔，就写写自己的一些心点，没有大用 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-15 09:21:03 "},"technology/":{"url":"technology/","title":"技术类","keywords":"","body":"这里是技术内文件 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-15 14:36:29 "},"technology/axios知识点.html":{"url":"technology/axios知识点.html","title":"axios知识点","keywords":"","body":"axios知识点及vue的使用axios方式 简介 Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中 ，它提供了一个更强大、更灵活的功能集。 特性 在浏览器中创建 XMLHttpRequests 在 node.js 则创建 http 请求 支持 Promise API 支持拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 支持Chrome、火狐、Edge、IE8+等浏览器 安装 使用 npm安装: $ npm install axios 使用 bower: $ bower install axios 或者直接使用 cdn: 使用举例 执行 GET 请求 注：推荐使用啥方法详情 // 为给定 ID 的 user 创建请求 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // GET 参数可以放到params里（推荐） get使用params参数内容 axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 还可以使用ECMAScript 2017里的async/await，添加 `async` keyword to your outer function/method. //使用async/await使用详情 async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); } } async/await 是 ECMAScript 2017新提供的功能 ，Internet Explorer 和一些旧的浏览器并不支持 执行 POST 请求 //post使用的是对象，这里也要注意 axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 axios.all //注意axios.all的使用流程等 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { // 两个请求现在都执行完成 })); axios API 可以通过向 axios 传递相关配置来创建请求 。请求图片要考虑下为什么，是什么原因？ axios(config) // 发送 POST 请求 axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' } }); // GET 请求远程图片 response参数 axios({ method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream' }) .then(function(response) { response.data.pipe(fs.createWriteStream('ada_lovelace.jpg')) }); axios(url[, config]) // 发送 GET 请求（默认的方法） axios('/user/12345'); 请求方法的别名 为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 并发 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例 可以使用自定义配置新建一个 axios 实例 axios.create([config]) const instance = axios.create({ baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: {'X-Custom-Header': 'foobar'} }); 实例方法 以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置项 下面是创建请求时可用的配置选项，注意只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 { // `url` 是用于请求的服务器 URL url: \"/user\", // `method` 是创建请求时使用的方法 method: \"get\", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: \"https://some-domain.com/api/\", // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 \"PUT\", \"POST\" 和 \"PATCH\" 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {\"X-Requested-With\": \"XMLHttpRequest\"}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: \"brackets\"}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: \"Fred\" }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: \"janedoe\", password: \"s00pers3cret\" }, // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\" responseType: \"json\", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: \"XSRF-TOKEN\", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // \"proxy\" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: \"127.0.0.1\", port: 9000, auth: : { username: \"mikeymike\", password: \"rapunz3l\" } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 响应结构 axios请求的响应包含以下信息： { // `data` 由服务器提供的响应 data: {}, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: \"OK\", // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用 then 时，会接收下面这样的响应： axios.get(\"/user/12345\") .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置的默认值/defaults 你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值 axios.defaults.baseURL = \"https://api.example.com\"; axios.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; axios.defaults.headers.post[\"Content-Type\"] = \"application/x-www-form-urlencoded\"; 自定义实例默认值 // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: \"https://api.example.com\" }); // 在实例已创建后修改默认值 instance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; 配置的优先级 配置会以一个优先顺序进行合并。 请求的config > 实例的 defaults 属性 > 库默认值： // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： var myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 var instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); 错误处理 axios.get(\"/user/12345\") .catch(function (error) { if (error.response) { // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else { // Something happened in setting up the request that triggered an Error console.log(\"Error\", error.message); } console.log(error.config); }); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围 axios.get(\"/user/12345\", { validateStatus: function (status) { return status 取消请求 使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： const CancelToken = axios.CancelToken; const source = CancelToken.source(); axios.get('/user/12345', { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // handle error } }); axios.post('/user/12345', { name: 'new name' }, { cancelToken: source.token }) // cancel the request (the message parameter is optional) source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： var CancelToken = axios.CancelToken; var cancel; axios.get(\"/user/12345\", { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // 取消请求 cancel(); 可以使用同一个 cancel token 取消多个请求 请求时使用 application/x-www-form-urlencoded axios会默认序列化 JavaScript 对象为 JSON. 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置. 浏览器 在浏览器环境，你可以使用 URLSearchParams API : const params = new URLSearchParams(); params.append('param1', 'value1'); params.append('param2', 'value2'); axios.post('/foo', params); URLSearchParams不是所有的浏览器均支持 除此之外，你可以使用qs库来编码数据: const qs = require('qs'); axios.post('/foo', qs.stringify({ 'bar': 123 })); // Or in another way (ES6), import qs from 'qs'; const data = { 'bar': 123 }; const options = { method: 'POST', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify(data), url, }; axios(options); 当然，同浏览器一样，你还可以使用 qs library. Promises axios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. TypeScript支持 axios 包含 TypeScript definitions. import axios from \"axios\"; axios.get(\"/user?ID=12345\"); vue中使用axios的多种方式 安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入 为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton 使用npm npm install axios 使用cdn: 解决post方法使用application/x-www-form-urlencoded格式编码数据 设置 headers:{ 'Content-type': 'application/x-www-form-urlencoded'} axios.post('url',data,{headers:{ 'Content-type': 'application/x-www-form-urlencoded'}}) // 不想在每次请求都设置的话，可以集中设置下 axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'; 仅仅这样并没有达到想要的效果，post的body主体中还是{\"age\":10}这样的格 式，并不是我们想要的query参数。引入Qs，这个库是axios里面包含的，不需要再下载了 import qs from 'qs' var data = qs.stringify({\"name\":\"xie\"}); axios.post('url',data).then() axios默认是不让ajax请求头部携带cookie的 axios 解决跨域cookie丢失问题 设置 axios.defaults.withCredentials = true 即可 示例代码： axios.defaults.withCredentials = true; var param = new URLSearchParams(); param.append(\"vCode\",vcode); axios.post('http://localhost',param) .then(function(res) { var rs=res.data; console.log(rs.data); }) .catch(function(err) { console.log(err); }); 配合vue axios并没有install 方法，所以是不能使用vue.use()方法的。 那么难道每个文件都要来引用一次？解决方法有很多种： 结合 vue-axios使用 axios 改写为 Vue 的原型属性 结合 Vuex的action 方法1：结合 vue-axios使用 vue-axios 用于将axios集成到Vuejs的小包装器 github: https://github.com/axios/axios 安装： npm install --save axios vue-axios vue-axios是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了 首先在主入口文件main.js中引用 import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios,axios); 之后就可以使用了，在组件文件中的methods里去使用了 getNewsList(){ this.axios.get('api/getNewsList').then((response)=>{ this.newsList=response.data.data; }).catch((response)=>{ console.log(response); }) }, 方法2： axios 改写为 Vue 的原型属性 首先在主入口文件main.js中引用，之后挂在vue的原型链上 import axios from 'axios' Vue.prototype.$axios= axios 在组件中使用 this.$axios.get('api/getNewsList').then((response)=>{ this.newsList=response.data.data; }).catch((response)=>{ console.log(response); }) 方法3：结合vuex import axios from 'axios' import { Message } from 'element-ui' import store from '@/store' import { getToken } from '@/utils/auth' // 创建axios实例 const service = axios.create({ baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间 }) // request拦截器 service.interceptors.request.use(config => { // Do something before request is sent if (store.getters.token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } return config }, error => { // Do something with request error console.log(error) // for debug Promise.reject(error) }) // respone拦截器 service.interceptors.response.use( response => response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) { // Message({ // message: res.message, // type: 'error', // duration: 5 * 1000 // }); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', { // confirmButtonText: '重新登录', // cancelButtonText: '取消', // type: 'warning' // }).then(() => { // store.dispatch('FedLogOut').then(() => { // location.reload();// 为了重新实例化vue-router对象 避免bug // }); // }) // } // return Promise.reject('error'); // } else { // return response.data; // } error => { console.log('err' + error)// for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }) return Promise.reject(error) }) export default service import request from '@/utils/request' //使用 export function getInfo(params) { return request({ url: '/user/info', method: 'get', params }); } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-14 15:47:03 "},"technology/WebSocket.html":{"url":"technology/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket WebSocket 是一种网络通信协议，很多高级功能都需要它。 一、为什么需要 WebSocket？ 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 二、简介 WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 三、客户端的简单示例 WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 var ws = new WebSocket(\"wss://echo.websocket.org\"); ws.onopen = function(evt) { console.log(\"Connection open ...\"); ws.send(\"Hello WebSockets!\"); }; ws.onmessage = function(evt) { console.log( \"Received Message: \" + evt.data); ws.close(); }; ws.onclose = function(evt) { console.log(\"Connection closed.\"); }; 四、客户端的 API WebSocket 客户端的 API 如下。 4.1 WebSocket 构造函数 WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 var ws = new WebSocket('ws://localhost:8080'); 4.2 webSocket.readyState readyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 switch (ws.readyState) { case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break; } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-13 18:40:40 "},"technology/智能照明项目说明.html":{"url":"technology/智能照明项目说明.html","title":"智能照明项目说明","keywords":"","body":"ut-smart-light 智能照明项目前端工程 环境和依赖 node v10.16.x yarn v1.19.1 webpack eslint @vue/cli ~3 ant-design-vue - Ant Design Of Vue 实现 vue-cropper - 头像裁剪组件 @antv/g2 - Alipay AntV 数据可视化图表 Viser-vue - antv/g2 封装实现 ant-design-vue-pro - 定制文档 权限管理 - admin pro权限管理思路 移除权限校验参考 - 移除模板中的权限管理 请注意，我们强烈建议本项目使用 Yarn 包管理工具，这样可以与本项目演示站所加载完全相同的依赖版本 (yarn.lock) 。由于我们没有对依赖进行强制的版本控制，采用非 yarn 包管理进行引入时，可能由于 Pro 所依赖的库已经升级版本而引入了新版本所导致的问题。作者可能会由于时间问题无法及时排查而导致您采用本项目作为基项目而出现问题。 项目下载和运行 拉取项目代码 git clone http://192.168.104.43/utfe/ut-smart-light.git cd ut-smart-light 安装依赖 yarn install 开发模式运行 yarn run serve 编译项目 yarn run build Lints and fixes files yarn run lint 其他说明 项目使用的 vue-cli3, 请更新您的 cli 关闭 Eslint (不推荐) 移除 package.json 中 eslintConfig 整个节点代码, vue.config.js 下的 lintOnSave 值改为 false 开启组件按需加载 /src/main.js L7 修改为 import './core/lazy_use' 修改 Ant Design 配色，在文件 vue.config.js 中，其他 less 变量覆盖参考 ant design 官方说明 css: { loaderOptions: { less: { modifyVars: { /* less 变量覆盖，用于自定义 ant design 主题 */ 'primary-color': '#F5222D', 'link-color': '#F5222D', 'border-radius-base': '4px', }, javascriptEnabled: true, } } } 约定式提交和git-flow 本项目commit message遵守约定式提交 代码管理遵守git-flow工作流模式 约定式提交 npm vs yarn 命令对比: https://yarnpkg.com/zh-Hans/docs/migrating-from-npm#toc-cli-commands-comparison 项目相关资料 需求文档：http://192.168.104.43/lightProduct/product 蓝狐设计稿：https://lanhuapp.com/url/7e6lW-qm3Ne （如果没有权限找陈迪强邀请） 表单校验 项目中所有设计的表单组件必须有约束和校验（特殊要求除外）. 模块结构相关约定 举例：设备模块 device # 功能模块 ├── common # 公共层（需要时才建立） ├── components # 公共组件（需要时才建立） ├── services # 接口服务层（service依赖api+transformer，做参数的处理和结果的转换） ├── transformers # 转换层（前端组件数据结构和服务端结果不一致再这里转换） └── views # 子功能模块 ├── device-controller # 设备控制子模块 (下面的子目录还可以继续重复上层的结构) │ ├── common │ ├── components │ ├── services │ └── transformers ├── device-manage # 设备管理子模块 └── region-manage # 区域分组子模块 这样做的好处是把基于模块化的思想，就近原则管理自己的依赖 如果子模块之间有依赖，就需要把依赖抽象提取到父模块中，变成一个公共依赖，防止循环依赖。 目录和文件命名约定 目录名称：kebab-case 全部小写，连字符-链接多个单词 文件名称：PascalCase 全部大写驼峰（通用的默认约定除外，例如：index.vue, index.js...之类.） Ajax模块注意事项 const url = '/api/web/user/delete/batch' const data = { id: 123 } // 因为Ajax和axios内部对data没有进行序列化处理，所以axios会根据data的类型进行切换 // 'Content-Type'，如果时string就使用 application/x-www-form-urlencoded // 不是string类型，就使用application/json，但是服务端接口不一定能够调用成功， // 所以**非string**类型最好使用`qs`处理下 // 调用src/api/utils中的stringify Ajax.post(url, data) // Ajax.post(url, stringify(data)) WebSocket 项目中的WebSocket已经对接完毕，数据转换已经完成 业务页面使用 import { PubSubBus } from '@commonset/pubsubbus' export default { mounted () { // data的数据结构看import('@commonset/types').CommonEvent PubSubBus.$on('eventName', (eventName, data) => { // 干你想干的事 }) this.$once('hook:beforeDestroy', function () { PubSubBus.$off('eventName') }) } } 事件类型和数据结构 src/common/websocket/constants/EventConstants.js ```javascript // 转换器的代码 export const smartHomeMessageTransformer = { /** transform - 转换 @param { import('@/types').SmartHomeEvent } data @returns { import('@commonset/types').CommonEvent } - 通过用的消息结构 */ transform: function (data) { return { type: data.type, code: 0, message: ${data.eventType}.${data.bussType}, data: { content: '', extraProps: data.body } } } } > 事件类型 ```javascript export const SmartLightEventTypes = { 'device.status.update': '设备状态更新', 'host.status.update': '主机状态更新', 'user.update': '用户信息更新，后跟角色类型', 'user.update.superAdminlight': '超级管理员', 'user.update.administrator': '管理员', 'user.update.operator': '操作员', 'user.update.reporter': '告警人', 'user.delete': '用户被删除，后跟角色类型', 'user.delete.superAdminlight': '超级管理员', 'user.delete.administrator': '管理员', 'user.delete.operator': '操作员', 'user.delete.reporter': '告警人', 'region.update': '区域信息更新', 'region.delete': '区域被删除', 'message.add': '有新消息，后跟消息类型', 'message.add.warning': '告警消息', 'scene.update': '策略方案更新，后跟linkageType、periodType', 'scene.delete': '策略方案被删除，后跟linkageType periodType', 'scene.delete.manual': '手动策略方案', 'scene.delete.auto.daily': '日方案', 'scene.delete.auto.weekly': '周方案', 'scene.delete.auto.holiday': '节假日方案', 'scene.update.manual': '手动策略方案', 'scene.update.auto.daily': '日方案', 'scene.update.auto.weekly': '周方案', 'scene.update.auto.holiday': '节假日方案' } 数据结构 // 其中的body字段，全部转换到extraProps字段上 // 转换之后的数据结构，业务界面接收到的数据结构 { type: data.type, code: 0, message: `${data.eventType}.${data.bussType}`, data: { content: '', extraProps: data.body } } { \"设备状态更新\": { \"type\": \"device.status.update\", \"bussType\": 7000, \"eventType\": 4, \"body\": { \"deviceId\": 1, \"productDevId\": 0, \"productDevStatus\": 0 } }, \"主机状态更新\": { \"type\": \"host.status.update\", \"bussType\": 7001, \"eventType\": 4, \"body\": { \"hostId\": 1, \"hostStatus\": 1 } }, \"eventType\": { \"1\": \"新增\", \"2\": \"删除\", \"3\": \"修改\" }, \"新增\": { \"type\": \"*.add\", \"bussType\": 0, \"eventType\": 1, \"body\": { \"entityId\": 1 } }, \"修改\": { \"type\": \"*.update\", \"bussType\": 0, \"eventType\": 3, \"body\": { \"entityId\": 1 } }, \"删除\": { \"type\": \"*.delete\", \"bussType\": 0, \"eventType\": 2, \"body\": { \"entityId\": 1, \"messageContent\": \"提示信息\" } } } vue-ext目录 vue-ext目录，放置对vue的扩展， main文件中调用setup方法 mixins 目前扩展了vue，添加了两个方法 // api mixins两个函数，方便对api结果处理。 import { apiResolveHandler, apiRejectHandler } from '@/api/utils' export default { methods: { apiResolver: apiResolveHandler, apiRejecter: apiRejectHandler } } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-14 09:41:07 "},"technology/理解Vue.mixin，利用Vue.mixin正确的偷懒.html":{"url":"technology/理解Vue.mixin，利用Vue.mixin正确的偷懒.html","title":"理解Vue.mixin，利用Vue.mixin正确的偷懒","keywords":"","body":"理解Vue.mixin，利用Vue.mixin正确的偷懒 刚进入vue项目，有部分细节功能不清楚。段期做了一个vue项目，看到使用vue.mixin功能，就想去了解透怎么应用及使用原理，故有了下文 关于Vue.mixin ，官方解释如下 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。 （不理解，所以看只有看例子咯） Vue.mixin为我们提供了两种混入方式：局部混入和全局混入； （好像有关vue都基本上都有局部与合局加载一说，~） 局部混入 顾名思义就是部分混入，也就是只有引入了mixin的混入对象才可以使用，并且只有在引入了mixin混入对象的组件中才生效； 首先自己搭建Vue的开发环境，然后我们在src目录中新建两个vue文件，分别是page1.vue和page2.vue； //page1.vue page1的值是: export default { data () { return { } }, } //page2.vue page2的值是: export default { data () { return { } } } //app.vue page1 page2 export default { name: 'App', methods:{ method1(){ this.$router.push('/page1'); }, method2(){ this.$router.push('/page2'); } } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 在src目录下创建router.js文件，配置路由实现跳转 // router.js import Vue from \"vue\"; import VueRouter from \"vue-router\"; Vue.use(VueRouter); import page1 from \"./page1\"; import page2 from \"./page2\"; const routes=[ {path:\"/page1\",component:page1}, {path:\"/page2\",component:page2} ] const router=new VueRouter({ routes }) export default router 最后将路由引入main.js中： // main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router.js' Vue.config.productionTip = false /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '' }) 完成上述准备工作之后，我们可以看到现在的页面效果如下： 没有报错，我们开始正式进入学习Vue.mixin： 注：终于开始学习了，难得呀 首先我们在src目录下新建一个名为mixin的文件夹并在mixin文件中创建一个mixin.js文件： //抛出混入对象，方便外部访问 mixin.js export const mixin={ data(){ return { number:1 } } } 可以看到我们在混入对象中创建了一个变量，是的，混入对象跟Vue实例的格式是一样的； 然后我们可以将mixin.js引入到我们的page1.vue和page2.vue中 // page1.vue //这里读的值其实是mixin的值，因为这个时候mixin已经混入到vue实例中了 page1的值是: //引入mixin.js import {mixin} from \"./mixin/mixin\" export default { //这里注意：属性名为mixins，值为数组类型 mixins:[mixin], data () { return { } }, } // page2.vue page2的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } } } 这个时候我们的混入对象已经成功混入到Vue实例中，你们可以点击看看效果，是可以正常运行并且能读取到值的； 现在我们来修改page1.vue的代码： //page1.vue page2的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } } } page2不变，再运行可以发现，我们的page1.vue中的值是执行了mounted，所以产生了自增 由此，我们可以知道mixin混入对象的变量是不会共享的；也就是你page1发生了变化，并不会通知mixin进行实时刷新数据，发生的变化只会在page1.vue中生效，不影响其他组件； 现在我们修改mixin.js和page1.vue中的代码： // mixin.js export const mixin={ data(){ return { number:1 } }, created(){ console.log(\"mixin混入对象\") } } // page1.vue page1的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } }, created(){ console.log(\"这里是page1\"); } } 这个时候我们再运行可以发现控制台输出是这个样子的： 是的，mixin混入对象中声明了：如果是同名钩子函数将合并为一个数组，因此都被调用，但是混入对象的钩子将在自身实例钩子之前触发； 值为对象的选项，例如methods,components等如果变量名和mixin混入对象的变量名发生冲突，将会以组件优先并进行递归合并，相当于组件数据直接覆盖了mixin中的同名数据； 我们可以修改代码mixin.js和page1.vue // mixin.js export const mixin={ data(){ return { number:1 } }, methods:{ demo1(){ console.log(\"mixin混入对象\") } } } //page1.vue page1的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { number:10 } }, mounted(){ this.demo1(); }, methods:{ demo1(){ console.log(\"这里是page1\"); } } } 运行代码我们可以很清晰的看到都是执行我们组件内的值； 因为在vue中我们在实例中声明变量也是通过键值对的形式来声明的，其实也是一个对象； 全局混入 全局混入我们只需要把mixin.js引入到main.js中，然后将mixin放入到Vue.mixin()方法中即可； // main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router.js' import mixin from \"./mixin/mixin.js\" Vue.config.productionTip = false Vue.mixin(mixin) /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '' }) 是的，全局混入更为便捷，我们将不用在子组件声明，全局混入将会影响每一个组件的实例，使用的时候需要小心谨慎；这样全局混入之后，我们可以直接在组件中通过this.变量/方法来调用mixin混入对象的变量/方法； 很多同学可能看到这里会有一些疑问，这不就跟Vuex差不多嘛，其实不是的： mixin混入对象和Vuex的区别： Vuex是状态共享管理，所以Vuex中的所有变量和方法都是可以读取和更改并相互影响的； mixin可以定义公用的变量或方法，但是mixin中的数据是不共享的，也就是每个组件中的mixin实例都是不一样的，都是单独存在的个体，不存在相互影响的； mixin混入对象值为函数的同名函数选项将会进行递归合并为数组，两个函数都会执行，只不过先执行mixin中的同名函数； mixin混入对象值为对象的同名对象将会进行替换，都优先执行组件内的同名对象，也就是组件内的同名对象将mixin混入对象的同名对象进行覆盖； Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-15 14:50:50 "}}