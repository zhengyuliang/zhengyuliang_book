{"./":{"url":"./","title":"说明","keywords":"","body":"技术文章简介 总结所有技术文章，以后方像汇总，装订成书，并发表于网络 前端技术知识 技术知识主要来源于网络与我这段时间的学习所得，合适的时候本人也会按自己的思路去编写一定的技术文档 生活经验总结 经验总结而尔，就写写自己的一些心点，没有大用 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-15 09:21:03 "},"technology/":{"url":"technology/","title":"技术类","keywords":"","body":"这里是技术说明 每天记录一篇技术文，复习一遍其中一篇技术文章 WebSocket vue 高级技巧 Vue.set()和this.$set()应用的场景 JavaScript之防抖（Debounce）和节流（Throttle） JavaScript数组求并集，交集和差集 探讨JavaScript的优雅写法 ES6之Set和Map数据结构深入学习 axios知识点 理解Vue.mixin，利用Vue.mixin正确的偷懒 7道javascript题，让你理解基本的javascript 异步神器Async-await介绍与填坑 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-27 10:08:42 "},"technology/axios知识点.html":{"url":"technology/axios知识点.html","title":"axios知识点","keywords":"","body":"axios知识点及vue的使用axios方式 简介 Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中 ，它提供了一个更强大、更灵活的功能集。 特性 在浏览器中创建 XMLHttpRequests 在 node.js 则创建 http 请求 支持 Promise API 支持拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 支持Chrome、火狐、Edge、IE8+等浏览器 安装 使用 npm安装: $ npm install axios 使用 bower: $ bower install axios 或者直接使用 cdn: 使用举例 执行 GET 请求 注：推荐使用啥方法详情 // 为给定 ID 的 user 创建请求 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // GET 参数可以放到params里（推荐） get使用params参数内容 axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 还可以使用ECMAScript 2017里的async/await，添加 `async` keyword to your outer function/method. //使用async/await使用详情 async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); } } async/await 是 ECMAScript 2017新提供的功能 ，Internet Explorer 和一些旧的浏览器并不支持 执行 POST 请求 //post使用的是对象，这里也要注意 axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 axios.all //注意axios.all的使用流程等 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { // 两个请求现在都执行完成 })); axios API 可以通过向 axios 传递相关配置来创建请求 。请求图片要考虑下为什么，是什么原因？ axios(config) // 发送 POST 请求 axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' } }); // GET 请求远程图片 response参数 axios({ method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream' }) .then(function(response) { response.data.pipe(fs.createWriteStream('ada_lovelace.jpg')) }); axios(url[, config]) // 发送 GET 请求（默认的方法） axios('/user/12345'); 请求方法的别名 为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 并发 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例 可以使用自定义配置新建一个 axios 实例 axios.create([config]) const instance = axios.create({ baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: {'X-Custom-Header': 'foobar'} }); 实例方法 以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置项 下面是创建请求时可用的配置选项，注意只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 { // `url` 是用于请求的服务器 URL url: \"/user\", // `method` 是创建请求时使用的方法 method: \"get\", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: \"https://some-domain.com/api/\", // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 \"PUT\", \"POST\" 和 \"PATCH\" 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {\"X-Requested-With\": \"XMLHttpRequest\"}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: \"brackets\"}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: \"Fred\" }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: \"janedoe\", password: \"s00pers3cret\" }, // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\" responseType: \"json\", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: \"XSRF-TOKEN\", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // \"proxy\" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: \"127.0.0.1\", port: 9000, auth: : { username: \"mikeymike\", password: \"rapunz3l\" } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 响应结构 axios请求的响应包含以下信息： { // `data` 由服务器提供的响应 data: {}, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: \"OK\", // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用 then 时，会接收下面这样的响应： axios.get(\"/user/12345\") .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置的默认值/defaults 你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值 axios.defaults.baseURL = \"https://api.example.com\"; axios.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; axios.defaults.headers.post[\"Content-Type\"] = \"application/x-www-form-urlencoded\"; 自定义实例默认值 // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: \"https://api.example.com\" }); // 在实例已创建后修改默认值 instance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; 配置的优先级 配置会以一个优先顺序进行合并。 请求的config > 实例的 defaults 属性 > 库默认值： // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： var myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 var instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); 错误处理 axios.get(\"/user/12345\") .catch(function (error) { if (error.response) { // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else { // Something happened in setting up the request that triggered an Error console.log(\"Error\", error.message); } console.log(error.config); }); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围 axios.get(\"/user/12345\", { validateStatus: function (status) { return status 取消请求 使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： const CancelToken = axios.CancelToken; const source = CancelToken.source(); axios.get('/user/12345', { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // handle error } }); axios.post('/user/12345', { name: 'new name' }, { cancelToken: source.token }) // cancel the request (the message parameter is optional) source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： var CancelToken = axios.CancelToken; var cancel; axios.get(\"/user/12345\", { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // 取消请求 cancel(); 可以使用同一个 cancel token 取消多个请求 请求时使用 application/x-www-form-urlencoded axios会默认序列化 JavaScript 对象为 JSON. 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置. 浏览器 在浏览器环境，你可以使用 URLSearchParams API : const params = new URLSearchParams(); params.append('param1', 'value1'); params.append('param2', 'value2'); axios.post('/foo', params); URLSearchParams不是所有的浏览器均支持 除此之外，你可以使用qs库来编码数据: const qs = require('qs'); axios.post('/foo', qs.stringify({ 'bar': 123 })); // Or in another way (ES6), import qs from 'qs'; const data = { 'bar': 123 }; const options = { method: 'POST', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify(data), url, }; axios(options); 当然，同浏览器一样，你还可以使用 qs library. Promises axios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. TypeScript支持 axios 包含 TypeScript definitions. import axios from \"axios\"; axios.get(\"/user?ID=12345\"); vue中使用axios的多种方式 安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入 为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton 使用npm npm install axios 使用cdn: 解决post方法使用application/x-www-form-urlencoded格式编码数据 设置 headers:{ 'Content-type': 'application/x-www-form-urlencoded'} axios.post('url',data,{headers:{ 'Content-type': 'application/x-www-form-urlencoded'}}) // 不想在每次请求都设置的话，可以集中设置下 axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'; 仅仅这样并没有达到想要的效果，post的body主体中还是{\"age\":10}这样的格 式，并不是我们想要的query参数。引入Qs，这个库是axios里面包含的，不需要再下载了 import qs from 'qs' var data = qs.stringify({\"name\":\"xie\"}); axios.post('url',data).then() axios默认是不让ajax请求头部携带cookie的 axios 解决跨域cookie丢失问题 设置 axios.defaults.withCredentials = true 即可 示例代码： axios.defaults.withCredentials = true; var param = new URLSearchParams(); param.append(\"vCode\",vcode); axios.post('http://localhost',param) .then(function(res) { var rs=res.data; console.log(rs.data); }) .catch(function(err) { console.log(err); }); 配合vue axios并没有install 方法，所以是不能使用vue.use()方法的。 那么难道每个文件都要来引用一次？解决方法有很多种： 结合 vue-axios使用 axios 改写为 Vue 的原型属性 结合 Vuex的action 方法1：结合 vue-axios使用 vue-axios 用于将axios集成到Vuejs的小包装器 github: https://github.com/axios/axios 安装： npm install --save axios vue-axios vue-axios是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了 首先在主入口文件main.js中引用 import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios,axios); 之后就可以使用了，在组件文件中的methods里去使用了 getNewsList(){ this.axios.get('api/getNewsList').then((response)=>{ this.newsList=response.data.data; }).catch((response)=>{ console.log(response); }) }, 方法2： axios 改写为 Vue 的原型属性 首先在主入口文件main.js中引用，之后挂在vue的原型链上 import axios from 'axios' Vue.prototype.$axios= axios 在组件中使用 this.$axios.get('api/getNewsList').then((response)=>{ this.newsList=response.data.data; }).catch((response)=>{ console.log(response); }) 方法3：结合vuex import axios from 'axios' import { Message } from 'element-ui' import store from '@/store' import { getToken } from '@/utils/auth' // 创建axios实例 const service = axios.create({ baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间 }) // request拦截器 service.interceptors.request.use(config => { // Do something before request is sent if (store.getters.token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } return config }, error => { // Do something with request error console.log(error) // for debug Promise.reject(error) }) // respone拦截器 service.interceptors.response.use( response => response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) { // Message({ // message: res.message, // type: 'error', // duration: 5 * 1000 // }); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', { // confirmButtonText: '重新登录', // cancelButtonText: '取消', // type: 'warning' // }).then(() => { // store.dispatch('FedLogOut').then(() => { // location.reload();// 为了重新实例化vue-router对象 避免bug // }); // }) // } // return Promise.reject('error'); // } else { // return response.data; // } error => { console.log('err' + error)// for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }) return Promise.reject(error) }) export default service import request from '@/utils/request' //使用 export function getInfo(params) { return request({ url: '/user/info', method: 'get', params }); } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-14 15:47:03 "},"technology/WebSocket.html":{"url":"technology/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket WebSocket 是一种网络通信协议，很多高级功能都需要它。 一、为什么需要 WebSocket？ 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 二、简介 WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 三、客户端的简单示例 WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 var ws = new WebSocket(\"wss://echo.websocket.org\"); ws.onopen = function(evt) { console.log(\"Connection open ...\"); ws.send(\"Hello WebSockets!\"); }; ws.onmessage = function(evt) { console.log( \"Received Message: \" + evt.data); ws.close(); }; ws.onclose = function(evt) { console.log(\"Connection closed.\"); }; 四、客户端的 API WebSocket 客户端的 API 如下。 4.1 WebSocket 构造函数 WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 var ws = new WebSocket('ws://localhost:8080'); 4.2 webSocket.readyState readyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 switch (ws.readyState) { case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break; } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-13 18:40:40 "},"technology/智能照明项目说明.html":{"url":"technology/智能照明项目说明.html","title":"智能照明项目说明","keywords":"","body":"ut-smart-light 智能照明项目前端工程 环境和依赖 node v10.16.x yarn v1.19.1 webpack eslint @vue/cli ~3 ant-design-vue - Ant Design Of Vue 实现 vue-cropper - 头像裁剪组件 @antv/g2 - Alipay AntV 数据可视化图表 Viser-vue - antv/g2 封装实现 ant-design-vue-pro - 定制文档 权限管理 - admin pro权限管理思路 移除权限校验参考 - 移除模板中的权限管理 请注意，我们强烈建议本项目使用 Yarn 包管理工具，这样可以与本项目演示站所加载完全相同的依赖版本 (yarn.lock) 。由于我们没有对依赖进行强制的版本控制，采用非 yarn 包管理进行引入时，可能由于 Pro 所依赖的库已经升级版本而引入了新版本所导致的问题。作者可能会由于时间问题无法及时排查而导致您采用本项目作为基项目而出现问题。 项目下载和运行 拉取项目代码 git clone http://192.168.104.43/utfe/ut-smart-light.git cd ut-smart-light 安装依赖 yarn install 开发模式运行 yarn run serve 编译项目 yarn run build Lints and fixes files yarn run lint 其他说明 项目使用的 vue-cli3, 请更新您的 cli 关闭 Eslint (不推荐) 移除 package.json 中 eslintConfig 整个节点代码, vue.config.js 下的 lintOnSave 值改为 false 开启组件按需加载 /src/main.js L7 修改为 import './core/lazy_use' 修改 Ant Design 配色，在文件 vue.config.js 中，其他 less 变量覆盖参考 ant design 官方说明 css: { loaderOptions: { less: { modifyVars: { /* less 变量覆盖，用于自定义 ant design 主题 */ 'primary-color': '#F5222D', 'link-color': '#F5222D', 'border-radius-base': '4px', }, javascriptEnabled: true, } } } 约定式提交和git-flow 本项目commit message遵守约定式提交 代码管理遵守git-flow工作流模式 约定式提交 npm vs yarn 命令对比: https://yarnpkg.com/zh-Hans/docs/migrating-from-npm#toc-cli-commands-comparison 项目相关资料 需求文档：http://192.168.104.43/lightProduct/product 蓝狐设计稿：https://lanhuapp.com/url/7e6lW-qm3Ne （如果没有权限找陈迪强邀请） 表单校验 项目中所有设计的表单组件必须有约束和校验（特殊要求除外）. 模块结构相关约定 举例：设备模块 device # 功能模块 ├── common # 公共层（需要时才建立） ├── components # 公共组件（需要时才建立） ├── services # 接口服务层（service依赖api+transformer，做参数的处理和结果的转换） ├── transformers # 转换层（前端组件数据结构和服务端结果不一致再这里转换） └── views # 子功能模块 ├── device-controller # 设备控制子模块 (下面的子目录还可以继续重复上层的结构) │ ├── common │ ├── components │ ├── services │ └── transformers ├── device-manage # 设备管理子模块 └── region-manage # 区域分组子模块 这样做的好处是把基于模块化的思想，就近原则管理自己的依赖 如果子模块之间有依赖，就需要把依赖抽象提取到父模块中，变成一个公共依赖，防止循环依赖。 目录和文件命名约定 目录名称：kebab-case 全部小写，连字符-链接多个单词 文件名称：PascalCase 全部大写驼峰（通用的默认约定除外，例如：index.vue, index.js...之类.） Ajax模块注意事项 const url = '/api/web/user/delete/batch' const data = { id: 123 } // 因为Ajax和axios内部对data没有进行序列化处理，所以axios会根据data的类型进行切换 // 'Content-Type'，如果时string就使用 application/x-www-form-urlencoded // 不是string类型，就使用application/json，但是服务端接口不一定能够调用成功， // 所以**非string**类型最好使用`qs`处理下 // 调用src/api/utils中的stringify Ajax.post(url, data) // Ajax.post(url, stringify(data)) WebSocket 项目中的WebSocket已经对接完毕，数据转换已经完成 业务页面使用 import { PubSubBus } from '@commonset/pubsubbus' export default { mounted () { // data的数据结构看import('@commonset/types').CommonEvent PubSubBus.$on('eventName', (eventName, data) => { // 干你想干的事 }) this.$once('hook:beforeDestroy', function () { PubSubBus.$off('eventName') }) } } 事件类型和数据结构 src/common/websocket/constants/EventConstants.js ```javascript // 转换器的代码 export const smartHomeMessageTransformer = { /** transform - 转换 @param { import('@/types').SmartHomeEvent } data @returns { import('@commonset/types').CommonEvent } - 通过用的消息结构 */ transform: function (data) { return { type: data.type, code: 0, message: ${data.eventType}.${data.bussType}, data: { content: '', extraProps: data.body } } } } > 事件类型 ```javascript export const SmartLightEventTypes = { 'device.status.update': '设备状态更新', 'host.status.update': '主机状态更新', 'user.update': '用户信息更新，后跟角色类型', 'user.update.superAdminlight': '超级管理员', 'user.update.administrator': '管理员', 'user.update.operator': '操作员', 'user.update.reporter': '告警人', 'user.delete': '用户被删除，后跟角色类型', 'user.delete.superAdminlight': '超级管理员', 'user.delete.administrator': '管理员', 'user.delete.operator': '操作员', 'user.delete.reporter': '告警人', 'region.update': '区域信息更新', 'region.delete': '区域被删除', 'message.add': '有新消息，后跟消息类型', 'message.add.warning': '告警消息', 'scene.update': '策略方案更新，后跟linkageType、periodType', 'scene.delete': '策略方案被删除，后跟linkageType periodType', 'scene.delete.manual': '手动策略方案', 'scene.delete.auto.daily': '日方案', 'scene.delete.auto.weekly': '周方案', 'scene.delete.auto.holiday': '节假日方案', 'scene.update.manual': '手动策略方案', 'scene.update.auto.daily': '日方案', 'scene.update.auto.weekly': '周方案', 'scene.update.auto.holiday': '节假日方案' } 数据结构 // 其中的body字段，全部转换到extraProps字段上 // 转换之后的数据结构，业务界面接收到的数据结构 { type: data.type, code: 0, message: `${data.eventType}.${data.bussType}`, data: { content: '', extraProps: data.body } } { \"设备状态更新\": { \"type\": \"device.status.update\", \"bussType\": 7000, \"eventType\": 4, \"body\": { \"deviceId\": 1, \"productDevId\": 0, \"productDevStatus\": 0 } }, \"主机状态更新\": { \"type\": \"host.status.update\", \"bussType\": 7001, \"eventType\": 4, \"body\": { \"hostId\": 1, \"hostStatus\": 1 } }, \"eventType\": { \"1\": \"新增\", \"2\": \"删除\", \"3\": \"修改\" }, \"新增\": { \"type\": \"*.add\", \"bussType\": 0, \"eventType\": 1, \"body\": { \"entityId\": 1 } }, \"修改\": { \"type\": \"*.update\", \"bussType\": 0, \"eventType\": 3, \"body\": { \"entityId\": 1 } }, \"删除\": { \"type\": \"*.delete\", \"bussType\": 0, \"eventType\": 2, \"body\": { \"entityId\": 1, \"messageContent\": \"提示信息\" } } } vue-ext目录 vue-ext目录，放置对vue的扩展， main文件中调用setup方法 mixins 目前扩展了vue，添加了两个方法 // api mixins两个函数，方便对api结果处理。 import { apiResolveHandler, apiRejectHandler } from '@/api/utils' export default { methods: { apiResolver: apiResolveHandler, apiRejecter: apiRejectHandler } } Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-14 09:41:07 "},"technology/理解Vue.mixin，利用Vue.mixin正确的偷懒.html":{"url":"technology/理解Vue.mixin，利用Vue.mixin正确的偷懒.html","title":"理解Vue.mixin，利用Vue.mixin正确的偷懒","keywords":"","body":"理解Vue.mixin，利用Vue.mixin正确的偷懒 刚进入vue项目，有部分细节功能不清楚。段期做了一个vue项目，看到使用vue.mixin功能，就想去了解透怎么应用及使用原理，故有了下文 关于Vue.mixin ，官方解释如下 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。 （不理解，所以看只有看例子咯） Vue.mixin为我们提供了两种混入方式：局部混入和全局混入； （好像有关vue都基本上都有局部与合局加载一说，~） 局部混入 顾名思义就是部分混入，也就是只有引入了mixin的混入对象才可以使用，并且只有在引入了mixin混入对象的组件中才生效； 首先自己搭建Vue的开发环境，然后我们在src目录中新建两个vue文件，分别是page1.vue和page2.vue； //page1.vue page1的值是: export default { data () { return { } }, } //page2.vue page2的值是: export default { data () { return { } } } //app.vue page1 page2 export default { name: 'App', methods:{ method1(){ this.$router.push('/page1'); }, method2(){ this.$router.push('/page2'); } } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 在src目录下创建router.js文件，配置路由实现跳转 // router.js import Vue from \"vue\"; import VueRouter from \"vue-router\"; Vue.use(VueRouter); import page1 from \"./page1\"; import page2 from \"./page2\"; const routes=[ {path:\"/page1\",component:page1}, {path:\"/page2\",component:page2} ] const router=new VueRouter({ routes }) export default router 最后将路由引入main.js中： // main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router.js' Vue.config.productionTip = false /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '' }) 完成上述准备工作之后，我们可以看到现在的页面效果如下： 没有报错，我们开始正式进入学习Vue.mixin： 注：终于开始学习了，难得呀 首先我们在src目录下新建一个名为mixin的文件夹并在mixin文件中创建一个mixin.js文件： //抛出混入对象，方便外部访问 mixin.js export const mixin={ data(){ return { number:1 } } } 可以看到我们在混入对象中创建了一个变量，是的，混入对象跟Vue实例的格式是一样的； 然后我们可以将mixin.js引入到我们的page1.vue和page2.vue中 // page1.vue //这里读的值其实是mixin的值，因为这个时候mixin已经混入到vue实例中了 page1的值是: //引入mixin.js import {mixin} from \"./mixin/mixin\" export default { //这里注意：属性名为mixins，值为数组类型 mixins:[mixin], data () { return { } }, } // page2.vue page2的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } } } 这个时候我们的混入对象已经成功混入到Vue实例中，你们可以点击看看效果，是可以正常运行并且能读取到值的； 现在我们来修改page1.vue的代码： //page1.vue page2的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } } } page2不变，再运行可以发现，我们的page1.vue中的值是执行了mounted，所以产生了自增 由此，我们可以知道mixin混入对象的变量是不会共享的；也就是你page1发生了变化，并不会通知mixin进行实时刷新数据，发生的变化只会在page1.vue中生效，不影响其他组件； 现在我们修改mixin.js和page1.vue中的代码： // mixin.js export const mixin={ data(){ return { number:1 } }, created(){ console.log(\"mixin混入对象\") } } // page1.vue page1的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { } }, created(){ console.log(\"这里是page1\"); } } 这个时候我们再运行可以发现控制台输出是这个样子的： 是的，mixin混入对象中声明了：如果是同名钩子函数将合并为一个数组，因此都被调用，但是混入对象的钩子将在自身实例钩子之前触发； 值为对象的选项，例如methods,components等如果变量名和mixin混入对象的变量名发生冲突，将会以组件优先并进行递归合并，相当于组件数据直接覆盖了mixin中的同名数据； 我们可以修改代码mixin.js和page1.vue // mixin.js export const mixin={ data(){ return { number:1 } }, methods:{ demo1(){ console.log(\"mixin混入对象\") } } } //page1.vue page1的值是: import {mixin} from \"./mixin/mixin\" export default { mixins:[mixin], data () { return { number:10 } }, mounted(){ this.demo1(); }, methods:{ demo1(){ console.log(\"这里是page1\"); } } } 运行代码我们可以很清晰的看到都是执行我们组件内的值； 因为在vue中我们在实例中声明变量也是通过键值对的形式来声明的，其实也是一个对象； 全局混入 全局混入我们只需要把mixin.js引入到main.js中，然后将mixin放入到Vue.mixin()方法中即可； // main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router.js' import mixin from \"./mixin/mixin.js\" Vue.config.productionTip = false Vue.mixin(mixin) /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '' }) 是的，全局混入更为便捷，我们将不用在子组件声明，全局混入将会影响每一个组件的实例，使用的时候需要小心谨慎；这样全局混入之后，我们可以直接在组件中通过this.变量/方法来调用mixin混入对象的变量/方法； 很多同学可能看到这里会有一些疑问，这不就跟Vuex差不多嘛，其实不是的： mixin混入对象和Vuex的区别： Vuex是状态共享管理，所以Vuex中的所有变量和方法都是可以读取和更改并相互影响的； mixin可以定义公用的变量或方法，但是mixin中的数据是不共享的，也就是每个组件中的mixin实例都是不一样的，都是单独存在的个体，不存在相互影响的； mixin混入对象值为函数的同名函数选项将会进行递归合并为数组，两个函数都会执行，只不过先执行mixin中的同名函数； mixin混入对象值为对象的同名对象将会进行替换，都优先执行组件内的同名对象，也就是组件内的同名对象将mixin混入对象的同名对象进行覆盖； Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-15 14:50:50 "},"technology/7道javascript题，让你理解基本的javascript.html":{"url":"technology/7道javascript题，让你理解基本的javascript.html","title":"7道javascript题，让你理解基本的javascript","keywords":"","body":"7道javascript题，让你理解基本的javascript 如果你符合JavaScript高级开发人员的资格，在编码面试中很有可能会被问到一些刁钻的问题。 1. 意外的全局变量 问题 在以下代码中，typeof a和typeof b的值分别是什么： function foo() { let a = b = 0; a++; return a; } foo(); typeof a; // => ???typeof b; // => ??? 答案 让我们仔细看看第2行：let a = b = 0。这个语句确实声明了一个局部变量a。但是，它确实声明了一个全局变量b。 在foo()作用域或全局作用域中都没有声明变量 b ”。因此JavaScript将表达式 b = 0 解释为 window.b = 0。 b是一个偶然创建的全局变量。 在浏览器中，上述代码片段相当于: function foo() { let a; window.b = 0; a = window.b; a++; return a; } foo(); typeof a; // => 'undefined' typeof window.b; // => 'number' typeof a是 'undefined'。变量a仅在 foo()范围内声明，在外部范围内不可用。 typeof b等于'number'。b是一个值为 0的全局变量。 2. 数组 length 属性 问题 clothes[0] 的值是什么： const clothes = ['jacket', 't-shirt']; clothes.length = 0; clothes[0]; // => ??? 答案 数组对象的 length 属性有一个 特殊的行为: 减少length属性的值有一个副作用，就是会删除索引位于新旧长度值之间的元素。 因为 length的这种行为，当JavaScript执行clothes.length = 0 时，数组 clothes 中的所有项都被删除了。 clothes[0] 是undefined，因为 clothes 数组被清空了。 3. 鹰眼测试 问题 numbers 数组的内容是什么： const length = 4; const numbers = []; for (var i = 0; i ??? 答案 让我们仔细看看出现在左花括号{前面的分号; ： 很容易忽略这个分号，而它创建了一个空语句。空语句是不做任何事情的语句。 for() 在空语句（什么也不做）上循环了 4 次，忽略了实际上往数组里添加元素的代码块{ numbers.push(i + 1); }。 上述代码等同于： const length = 4; const numbers = []; var i; for (i = 0; i [5] for()递增变量i直到4。然后JavaScript 进入代码块 { numbers.push(i + 1); }，将4 + 1 添加 到numbers数组中。 这样 numbers 就是 [5]. 4. 自动插入分号 问题 function arrayFromValue(item) { return [items]; } arrayFromValue(10); // => ??? 答案 很容易忽略return关键字和[items]表达式之间的换行。 换行使JavaScript自动在return和[items]表达式之间插入一个分号。 这里有一段等价的代码，它在return后插入分号： function arrayFromValue(item) { return; [items]; } arrayFromValue(10); // => undefined 函数中的 return; 导致它返回 undefined。 因此 arrayFromValue(10) 的值是 undefined。 5. 经典问题：坑爹的闭包 问题 以下脚本将会在控制台输出什么： let i; for (i = 0; i { console.log(i); } setTimeout(log, 100); } 答案 如果你之前没有听说过这个棘手的问题，你的答案很可能是0, 1 和 2，这是不正确的。当我第一次尝试解答它时，我的答案也是这样！ 执行这个代码段包含两个步骤。 步骤 1 for()迭代3次。在每次迭代过程中，都会创建一个新的函数log()，它捕获变量 i。然后setTimout()执行log()。 当for()循环完成时，i变量的值为3。 log()是一个捕获变量 i 的闭包，它在for()循环的外部作用域定义。重要的是要理解闭包从词法上捕获了变量i 。 步骤 2 第2步在 100 毫秒后发生： setTimeout()调用了队列中的3个log() 回调。log() 读取变量 i的当前值，即3，并记录到控制台3。 这就是为什么控制台输出3, 3 和3。 你知道怎样让代码输出 0, 1, 和 2吗？请在评论里写出你的方案。 6. 浮点数问题 问题 等号判断的结果是什么？ 0.1 + 0.2 === 0.3 // => ??? 答案 首先，我们看看0.1 + 0.2 的值： 0.1 + 0.2; // => 0.30000000000000004 0.1 和 0.2 的和 不完全等于 0.3，而是略大于 0.3。 由于浮点数在二进制中的编码机制，像浮点数的加法这样的操作会受到舍入误差的影响。 简单地说，直接比较浮点数是不精确的。 因此 0.1 + 0.2 === 0.3 是 false. 7. 变量提升 问题 如果在声明之前访问myVar和myConst会发生什么? myVar; // => ???myConst; // => ??? var myVar = 'value'; const myConst = 3.14; 答案 变量提升和暂时性死区是影响JavaScript变量生命周期的两个重要概念。 在声明之前访问 myVar 结果为undefined。一个被提升的var变量，在它的初始化之前，有一个 undefined的值。 但是，在声明之前访问myConst会抛出 ReferenceError。在声明行const myConst = 3.14之前，const 变量处于暂时死区。 NND，这几道题，我一直也没有啥留意的，要我首次做，应该挂的也比较居多。这次从简书上看到，就记录一下，涨涨知识。吼~~~~ Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-18 15:18:04 "},"technology/异步神器Async-await介绍与填坑.html":{"url":"technology/异步神器Async-await介绍与填坑.html","title":"异步神器Async-await介绍与填坑","keywords":"","body":"异步神器Async-await介绍与填坑 神，请好好研究一下async-await功能，接下来的业务需求中，用处巨巨巨巨大，请同我学习，我教你们。 请每一行每一句的去了解，并使用些方法。坑要认真的填，别被埋了 async - 定义异步函数 async 译：异步，是 Generator 函数的语法糖。该函数会返回一个promise对象，可以使用then方法添加回调函数，如果在函数内直接 return，Async会通过Promise.resolve()将其封装成Promise()对象，也可以通过.then添加回调函数 async 为异步函数，请牢记 ，如下面例子 async function pms() { return 'abc' } console.log(pms()) // [object Promise] { ... } 以上方法执行返回了一个promise对象，其执行等效于 async function pms() { return new Promise((resolve, reject) => { resolve('abc') }) } 在没有配合await时，我们可以调用promise的.then方法得到执行结果。当然也会有.catch方法 pms().then(res => { console.log(res) // 'abc' }).catch(e => { console.log('错误') }) 坑1：async的使用，有await,就一定要async，牛逼人都应该能记住 await - 暂停异步函数的执行 您历害了，你历害了，没有你怎么处理，await不错 await，即：async wait，旨在等待异步执行结束，使用于async函数内部。异步未执行结束，阻塞当前代码。嗯哼？阻塞！！！   与线程阻塞不同的是，await 的阻塞发生在 async 函数内部，可以理解为一个异步的阻塞。跟在await后的JS表达式，可以等待很多类型的事件，但初衷是用于等待Promise对象。如果await的对象是promise对象，则阻塞异步函数代码执行等待promise的resolve状态，如果是同步执行的表达式则立即执行。 async/await的使用 function asyncFunc(time) { return new Promise((resolve, reject) => { setTimeout(() => { // 用setTimeout模拟异步 resolve('async result') }, time) }) } function normalFunc() { console.log('normal result') } async function awaitDemo() { await normalFunc() // 执行立即打印 normal result const res = await asyncFunc(1000) console.log(res) // 执行1s后打印 ‘async result’ } awaitDemo() // 执行 以上的例子比较常规，再看看下面这个例子 async function func() { console.log('123') } async function run() { const res = await func() console.log(res) // 123 } run() 该例子中，func看似一个普通函数，但经async定义后，会返回一个promise对象，此时的await等待的就是该promise对象的resolve参数，即123。 对比上一个例子中的normalFunc，主要有两个理解点 （1）增加了async的普通函数变成了一个异步函数，await等待的对象为promise对象，返回resolve参数 （2）await可以等待任何东西，如果等待的是普通内容，则直接返回该内容 【填坑1】异常处理 请用try-catch处理异常内容 细心的你应该已经发现，await 返回的是promise的resolve参数，但对于catch却没有实际的处理。那当我们的请求发生异常时，该怎么办？答案是使用try-catch，在Promise中的.catch()分支会流入catch中 function asyncFunc(time) { return new Promise((resolve, reject) => { setTimeout(() => { // 用setTimeout模拟异步 reject('promise reject') }, time) }) } // 为了处理Promise.reject 的情况我们应该将代码块用 try catch 捕获一下 async function awaitDemo() { try { const res = await asyncFunc(1000) console.log(res) } catch (err) { console.log(err.message || 'Uncatch Error') } } awaitDemo() // 如果没有使用try-catch，执行会报错 坑1很重要，请认识注重异常处理方式 【填坑2】并行请求 对于一个真实的业务需求，通常会有多个异步请求需要同时执行，如获取左侧目录树，和登录账户的用户信息等。因await遇到异步会阻塞，当一个async函数内有多个异步函数需要调用时，就会出现相互等待的现象。天哪，“异步” 变成了 “同步”了，这不是我们所希望的 function asyncFunc() { return new Promise((resolve, reject) => { setTimeout(() => { resolve('request done') }) }) } async function bugDemo() { await asyncFunc() await asyncFunc() await asyncFunc() console.log('finish') } 历害了，可能用paomise.all() 把异步变成同步 以上代码正常执行了，没有报出异常，但仔细观察控制台 timeline 可以发现，三个函数是同步顺序执行的，其罪魁祸首就是await的等待机制。那怎么解决这个问题？   其实async-await 只是promise的语法糖，但其并不能代替Promise，从对异常的处理上就可以看出，还需要引入try-catch ，本问题是另一个体现。解决办法需要使用promise的.all() promise.all( iterable )，当所有请求都为resolve时，返回resolve状态 async function correctDemo() { const f1 = asyncFunc() const f2 = asyncFunc() const f3 = asyncFunc() await Promise.all([f1, f2, f3]); console.log('finish') } 牛逼吧，要用Promise.all来处理同步，什么叫同步，就是更好的使用咯。 【填坑3】await必须在async的上下文中 await 并不只是使用在async 函数中即可，还必须在asyn函数的上下文中 // 虽在async函数里使用，但在forEach上下文中，异常 async function errorDemo() { [1, 2, 3, 4, 5].forEach(item => { await item; }); } errorDemo() // SyntaxError: await is only valid in async function // await 必须在async函数的上下文中 async function correctDemo() { let arr = [1, 2, 3, 4, 5]; for (let i = 0; i 理解没，我感觉到，本人好像理解，对，不是好像，是己经掌握 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-27 10:00:35 "},"technology/JavaScript数组求并集，交集和差集.html":{"url":"technology/JavaScript数组求并集，交集和差集.html","title":"JavaScript数组求并集，交集和差集","keywords":"","body":"JavaScript数组求并集，交集和差集 现有两数组a = [1, 2, 3]，b = [2, 4, 5]，求a，b数组的并集，交集和差集。 1、ES7方法 ES7新增了一个Array.prototype.includes的数组方法，用于返回一个数组是否包含指定元素，结合filter方法。 // 并集 let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5] // 交集 let intersection = a.filter(v => b.includes(v)) // [2] // 差集 let difference = a.concat(b).filter(v => a.includes(v) && !b.includes(v)) // [1,3] 2、ES6方法 ES6中新增的一个Array.from方法，用于将类数组对象和可遍历对象转化为数组。只要类数组有length长度，基本都可以转化为数组。结合Set结构实现数学集求解。 let a = [1, 2, 3] console.log(a) let b = [2, 4, 5] let aSet = new Set(a) let bSet = new Set(b) // 并集 let union = Array.from(new Set(a.concat(b))) // [1,2,3,4,5] console.log(union) // 交集 let intersection = Array.from(new Set(a.filter(v => bSet.has(v)))// [2] ) // 差集 let differenceNew = Array.from(new Set(a.concat(b).filter(v => aSet.has(v) && !bSet.has(v))) [1,3] ) console.log(differenceNew) ES5方法 ES5可以利用filter和indexOf进行数学集操作，但是，由于indexOf方法中NaN永远返回-1，所以需要进行兼容处理。 01不考虑NaN(数组中不含NaN) var a = [1,2,3]; var b = [2,4,5]; // 并集 var union = a.concat(b.filter(function(v) { return a.indexOf(v) === -1})) // [1,2,3,4,5] // 交集 var intersection = a.filter(function(v){ return b.indexOf(v) > -1 }) // [2] // 差集 var difference = a.filter(function(v){ return b.indexOf(v) === -1 })// [1,3] console.log(union) console.log(intersection) console.log(difference) 02考虑NaN var a = [1, 2, 3, NaN]; var b = [2, 4, 5]; var aHasNaN = a.some(function (v) { return isNaN(v) }) var bHasNaN = b.some(function (v) { return isNaN(v) }) // 并集 var union = a.concat(b.filter(function (v) { return a.indexOf(v) === -1 && !isNaN(v) })).concat(!aHasNaN & bHasNaN ? [NaN] : []) // [1,2,3,4,5,NaN] // 交集 var intersection = a.filter(function (v) { return b.indexOf(v) > -1 }).concat(aHasNaN & bHasNaN ? [NaN] : []) // [2] // 差集 var difference = a.filter(function (v) { return b.indexOf(v) === -1 && !isNaN(v) }).concat(aHasNaN && !bHasNaN ? [NaN] : [])//1,3,NaN console.log(union) console.log(intersection) console.log(difference) filter完成数组去重 var r; var arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index; }); alert(r); // 去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-25 14:13:31 "},"technology/JavaScript之防抖Debounce和节流Throttle.html":{"url":"technology/JavaScript之防抖Debounce和节流Throttle.html","title":"JavaScript之防抖Debounce和节流Throttle","keywords":"","body":"JavaScript之防抖（Debounce）和节流（Throttle） 一、背景 防抖和节流是两种不同的控制一个函数执行次数的方法，其目的都是为了节约计算机资源。 当我们操作DOM的时候，加上节流或者防抖就非常有必要，因为众所周知，操作DOM的开销是非常大的，所以要尽可能减少DOM操作次数。 // html Number of scroll events Reset 0 //css body { background: #444444; color: white; font: 15px/1.51 system, -apple-system, \".SFNSText-Regular\", \"San Francisco\", \"Roboto\", \"Segoe UI\", \"Helvetica Neue\", \"Lucida Grande\", sans-serif; margin:0 auto; max-width:600px; padding:20px; min-height:1000vh; /* 100 times viewport height */ } #counter { position:fixed; top:100px; left:40%; font-size:50px; } .reset { color:white; text-decoration:none; border:1px solid white; padding:10px 20px; background:rgba(0,0,0,0.1); } //js var i = 0; var $counter = $('#counter'); $(document).ready(function(){ $(document).on('scroll', function(){ $counter.html(i); i++; }); }); $('.reset').on('click', function(){ $counter.html(''); i = 0; }) 当鼠标滚动或者拖拽的时候可以轻易地每秒触发30个事件，而且在移动端慢速滚动可以达到每秒100次，要是这么短的时间内每次都触发一个或多个函数，那浏览器应该会卡死崩溃的，所以这就引出了防抖和节流。 二、防抖（Debounce） 例子： Trigger area Reset Raw events over time Debounced events 400ms, trailing body { background: #444444; color: white; font: 15px/1.51 system, -apple-system, \".SFNSText-Regular\", \"San Francisco\", \"Roboto\", \"Segoe UI\", \"Helvetica Neue\", \"Lucida Grande\", sans-serif; margin:0 auto; max-width:700px; padding:20px; } .events{ padding:0px 20px 10px 20px; height: 23px; } .events span { height:17px; width:6px; display:inline-block; border-right:1px solid #111; } .events span:last-of-type { border:2px solid black; border-bottom: 4px solid #AAA; border-top: 0px; margin-bottom:-17px; margin-left:-2px; } h2 { margin:10px 0 5px 0; clear:both; font-weight: normal; font-size:14px; padding:6px 20px; } .trigger-area { margin: 0; display:inline-block; width: 200px; height:50px; border: 1px solid #5ed1ff; padding: 28px 0 0 0; text-align: center; background-color: transparent; cursor:pointer; font-size:17px; -webkit-user-select: none; /* Chrome / Safari */ -moz-user-select: none; /* Firefox all */ -ms-user-select: none; /* IE 10+ */ user-select: none; /* Likely future */ } .trigger-area.active { background:#2F5065; } .clickme:hover, .clickme:active{ background-color: #333; } .clickme:active{ padding: 4px 5px; } .reset { display:inline-block; width: 120px; padding: 10px 0 0 0; text-align: center; font-size:14px; cursor:pointer; color:#eee; } .visualizations { margin-top:10px; background:rgba(0,0,0,0.2); } .details { font-size:13px; color:#999; } /* stating the obvious: color0 represents our empty color */ .color0 { transparent} .color1 { background-color: #FFE589} .color2 { background-color: #B9C6FF} .color3 { background-color: #99FF7E} .color4 { background-color: #FFB38A} .color5 { background-color: #A5FCFF} .color6 { background-color: #FF8E9B} .color7 { background-color: #E3FF7E} .color8 { background-color: #FFA3D8} .color9 { background-color: #5ca6ff} .color10 { background-color: #9BFFBB} $(document).ready(function(){ var $rawDiv = $('#raw-events'), $debounceDiv = $('#debounced-events'), $triggerArea = $('.trigger-area'), initialized = false, frequency = 100, barLength = 0, globalColor = 2, colorNeedChange = false, interval_id, rawColor = 0, debounceColor = 0, maxBarLength = 87; var drawDebouncedEvent = _.debounce(function(div){ debounceColor = globalColor; }, frequency*4, {leading:false, trailing:true}); var changeDebouncedColor = _.debounce(function(div){ // Change colors, to visualize easier the \"group of events\" that is reperesenting this debounced event globalColor++; if (globalColor > 9){ globalColor = 2; } }, frequency*4, {leading:false, trailing:true}); function draw_tick_marks(){ // every x seconds, draw a tick mark in the bar interval_id = setInterval(function(){ barLength++; $rawDiv.append(''); $debounceDiv.append(''); rawColor = 0; // make it transparent again debounceColor = 0; // make it transparent again if (barLength > maxBarLength){ clearInterval(interval_id); } }, frequency); }; // Track Mouse movement or clicks for mobile $triggerArea.on('click mousemove', function (){ if (!initialized) { initialized = true; draw_tick_marks(); $(this).addClass('active'); } rawColor = globalColor; drawDebouncedEvent(); changeDebouncedColor(); }); $('.reset').on('click', function(){ initialized = false; $triggerArea.removeClass('active'); $rawDiv.empty(); $debounceDiv.empty(); barLength = 0; clearInterval(interval_id); }); }); 具体实现 function debounce(func,delay) { let timer; return function(...args) { if (timer) { clearTimeout(timer); } timer = setTimeout(() => { func.apply(this,arguments); },delay) } } Lodash中实现 _.debounce 和 _.throttle 的功能很全面，可以直接使用，其中的 throttle函数是使用 _.debounce 新增 maxWait` 选项来实现的 Resize实例 // Based on http://www.paulirish.com/2009/throttled-smartresize-jquery-event-handler/ $(document).ready(function(){ var $win = $(window); var $left_panel = $('.left-panel'); var $right_panel = $('.right-panel'); function display_info($div) { $div.append($win.width() + ' x ' + $win.height() + ''); } $(window).on('resize', function(){ display_info($left_panel); }); $(window).on('resize', _.debounce(function() { display_info($right_panel); }, 400)); }); 输入验证实例 $(document).ready(function(){ var $statusKey = $('.status-key'); var $statusAjax = $('.status-ajax'); var intervalId; // Fake ajax request. Just for demo function make_ajax_request(e){ var that = this; $statusAjax.html('That\\'s enough waiting. Making now the ajax request'); intervalId = setTimeout(function(){ $statusKey.html('Type here. I will detect when you stop typing'); $statusAjax.html(''); $(that).val(''); // empty field },2000); } // Event handlers to show information when events are being emitted $('.autocomplete') .on('keydown', function (){ $statusKey.html('Waiting for more keystrokes... '); clearInterval(intervalId); }) // Display when the ajax request will happen (after user stops typing) // Exagerated value of 1.2 seconds for demo purposes, but in a real example would be better from 50ms to 200ms $('.autocomplete').on('keydown', _.debounce(make_ajax_request, 1300)); }); 当用户输入并且发起Ajax请求的时候，_.debounce可以用来实现防抖，比如间隔2秒未检测到用户输入才发起请求。 三、节流（Throttle） 具体实现 -- 使用定时器 var throttle = function(func, delay) { var timer = null; return function() { if (!timer) { timer = setTimeout(function() { func.apply(this,arguments); timer = null; },delay); } } } 另一种定时器写法： let isAllow = true; function throttle() { let fun = function() { if (!isAllow) return; let timer = setTimeout(() => { console.log(\"throttle\"); clearTimeout(timer); timer = null; isAllow = true; },1000); }; fun()； } 二者的区别是后者使用了isAllow标志位来判断是否需要执行函数。 滚动条实例 一个十分常见的例子，当用户的鼠标滚动的时候，检查鼠标位置离底部的距离，当接近底部时，发起Ajax请求。 Infinite scrolling throttled Block 1 Block 2 Block 3 Block 4 body { background: #444444; color: white; font: 15px/1.51 system, -apple-system, \".SFNSText-Regular\", \"San Francisco\", \"Roboto\", \"Segoe UI\", \"Helvetica Neue\", \"Lucida Grande\", sans-serif; margin:0 auto; max-width:600px; padding:20px; } .item { border:4px solid white; height:120px; width:100%; margin-bottom:50px; background:#333; padding:20px; } .color-1 { border-color: #9BFFBB} .color-2 { border-color: #B9C6FF} .color-3 { border-color: #FFA3D8} .color-4 { border-color: #FF8E9B} // Very simple example. // Probably you would want to use a // full-featured plugin like // https://github.com/infinite-scroll/infinite-scroll/blob/master/jquery.infinitescroll.js $(document).ready(function(){ // Check every 200ms the scroll position $(document).on('scroll', _.throttle(function(){ check_if_needs_more_content(); }, 300)); function check_if_needs_more_content() { pixelsFromWindowBottomToBottom = 0 + $(document).height() - $(window).scrollTop() -$(window).height(); // console.log($(document).height()); // console.log($(window).scrollTop()); // console.log($(window).height()); //console.log(pixelsFromWindowBottomToBottom); if (pixelsFromWindowBottomToBottom requestAnimationFrame requestAnimationFrame是另一种限制函数执行次数的方式，可以认为与_.throttle类似，但是其拥有更高的准确度，因为其本身就是为了更好的精确度而生的原生API。 requestAnimationFrame的优点 致力于60fps（16ms每帧），自己可以决定最好的渲染时间。 简单且标准的原生API，不太容易改变，减少维护成本。 requestAnimationFrame的缺点 需要手动开始或取消rAFs，.debounce 或 .throttle则不需要。 如果tab没有激活，则不会执行，即使触发 Ascroll, mouse 或者 keyboard 等事件也不行. 不支持 IE9, Opera Mini 和 老版本 Android. 不支持node.js，所以不能在服务端使用。 requestAnimationFrame实例 与_.throttle相比，同时设置 16ms， 相同的性能环境下，rAF 可以在更复杂的情况下拥有更好的结果。 四、结论 一般来说，如果你的JavaScript函数是直接绘制或者动画某些属性，那么可以使用requestAnimationFrame，在需要重新计算元素位置的地方使用。 需要发起Ajax请求，或者决定是否增加或删除一个类的时候，可以考虑使用_.debounce 或者_.throttle 。 debounce: 在事件被触发x秒后再执行回调，如果在这x秒内又被触发，则重新计时。 throttle: 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 requestAnimationFrame: 节流的另外一种选项，在函数重新计算或者渲染元素时，需要平滑过渡或者动画的时候使用。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-18 10:00:05 "},"technology/Vue.set和this.$set应用的场景.html":{"url":"technology/Vue.set和this.$set应用的场景.html","title":"Vue.set和this.$set应用的场景","keywords":"","body":"Vue.set()和this.$set()应用的场景 背景：在vue中改变对象的属性值或者通过索引改变数组时，对应修改的字段不会重新在页面渲染。 例如： const vueInstance = new Vue({ data: { arr: [1, 2], obj1: { a: 3 } } }); vueInstance.$data.arr[0] = 3; // 页面不会重新渲染 vueInstance.$data.obj1.b = 3; // 页面不会重新渲染 经过查看官方文档发现这部分说明如下： Vue.set()向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。 它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = 'hi') 所以按照官方的写法应该是： Vue.set(vueInstance.$data.arr, 0, 3); // 这样操作数组可以让页面重新渲染 vueInstance.$set(vueInstance.$data.arr, 0, 3); // 这样操作数组也可以让页面重新渲染 Vue.set(vueInstance.$data.obj1, b, 3); // 这样操作对象可以让页面重新渲染 vueInstance.$set(vueInstance.$data.obj1, b, 3); // 这样操作对象也可以让页面重新渲染 Vue.set()和this.$set()实现原理 是时候看一波这两个api的源码了，我们先来看看Vue.set()的源码： import { set } from '../observer/index' ... Vue.set = set ... 再来看看this.$set()的源码： import { set } from '../observer/index' ... Vue.prototype.$set = set ... 发现这两个api的实现原理基本一模一样，都是使用了set函数。 set函数是从 ../observer/index 文件中导出的，区别在于Vue.set()是将set函数绑定在Vue构造函数上，this.$set()是将set函数绑定在Vue原型上。 数组的实现原理 继续源码： if (Array.isArray(target) && isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } 首先if判断当前target是不是数组，并且key的值是有效的数组索引。 然后将target数组的长度设置为target.length和key中的最大值，这里为什么要这样做呢?是因为我们可能会进行下面这种骚操作： arr1 = [1,3]; Vue.set(arr1,10,1) // 如果不那样做，这种情况就会出问题 接着向下看，我们发现这里直接调用了target.splice(key, 1, val)，在前面我们说过调用arrayMethods提供的push、pop等7个方法可以导致页面重新渲染，刚好splice也是属性arrayMethods提供的7个方法中的一种。 总结一下Vue.set数组实现的原理： 其实Vue.set()对于数组的处理其实就是调用了splice方法，是不是发现其实很简单~~ 对象的实现原理 续看源码： if (key in target && !(key in Object.prototype)) { target[key] = val return val } 这里先判断如果key本来就是对象中的一个属性，并且key不是Object原型上的属性。说明这个key本来就在对象上面已经定义过了的，直接修改值就可以了，可以自动触发响应。 注意：对于新增的对象属性不会重新渲染，这也刚好解释了我们使用 vueInstance.$data.obj1.b = 3; 的时候为什么页面不会重新渲染，因为这里的属性b不是对象的已有属性，也就是说属性b没有进行过依赖收集，所以才会导致修改属性b的值页面不会重新渲染。 继续看源码： defineReactive(ob.value, key, val) ob.dep.notify() return val 这里其实才是vue.set()真正处理对象的地方。defineReactive(ob.value, key, val)的意思是给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染。 ob.dep.notify()这句代码的意思是触发当前的依赖（这里的依赖依然可以理解成渲染函数），所以页面就会进行重新渲染。 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-27 15:31:42 "},"technology/vue高级技巧.html":{"url":"technology/vue高级技巧.html","title":"vue高级技巧","keywords":"","body":"vue 高级技巧 1.css 局部样式 vue 中style样式添加scoped属性表示它的样式只作用于当前组件，样式私有化。 但是当前组件的根组件会受到父组件样式的影响。（比如父组件有个.box{background:red}, 如果子组件即当前组件的根组件类名也为box，那背景也会为red） 其中渲染的原理： 给HTML的DOM节点添加一个不重复的data属性 来表示唯一性 在对应的css选择器末尾添加一个当前组件的data属性选择器来私有化 如果使用了scoped属性后，想让组件内部样式被外部控制，只需要css添加 deep属性即可 .text-box { /deep/ input { width: 166px; text-align: center; } } 2. Vue.filter 全局过滤器 过滤器的目的主要是为了对数据进行转换 computed计算属性也可以转换，但是computed不能接受参数，只能针对某一个Vue内部属性进行转换，但是filter可以接受参数。 注册 全局过滤器 Vue.filter('globalFilter', value=>{....}) 组件过滤器 filters:{ testFilters: value=>{...} } 注：一直不怎么会用全局过滤器，有关全局的都不清楚，这要重点研究一下这里的知识 使用 在双花括号插值 Copyright © zhengyuliang all right reserved，powered by Gitbook该文件编写时间： 2019-11-19 15:54:47 "}}